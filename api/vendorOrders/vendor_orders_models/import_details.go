// Code generated by go-swagger; DO NOT EDIT.

package vendor_orders_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ImportDetails Import details for an import order.
//
// swagger:model ImportDetails
type ImportDetails struct {

	// Types and numbers of container(s) for import purchase orders. Can be a comma-separated list if the shipment has multiple containers. HC signifies a high-capacity container. Free-text field, limited to 64 characters. The format will be a comma-delimited list containing values of the type: $NUMBER_OF_CONTAINERS_OF_THIS_TYPE-$CONTAINER_TYPE. The list of values for the container type is: 40'(40-foot container), 40'HC (40-foot high-capacity container), 45', 45'HC, 30', 30'HC, 20', 20'HC.
	// Max Length: 64
	ImportContainers string `json:"importContainers,omitempty"`

	// Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only.
	// Enum: [ExWorks FreeCarrier FreeOnBoard FreeAlongSideShip CarriagePaidTo CostAndFreight CarriageAndInsurancePaidTo CostInsuranceAndFreight DeliveredAtTerminal DeliveredAtPlace DeliverDutyPaid]
	InternationalCommercialTerms string `json:"internationalCommercialTerms,omitempty"`

	// If the recipient requests, contains the shipment method of payment. This is for import PO's only.
	// Enum: [PaidByBuyer CollectOnDelivery DefinedByBuyerAndSeller FOBPortOfCall PrepaidBySeller PaidBySeller]
	MethodOfPayment string `json:"methodOfPayment,omitempty"`

	// The port where goods on an import purchase order must be delivered by the vendor. This should only be specified when the internationalCommercialTerms is FOB.
	// Max Length: 64
	PortOfDelivery string `json:"portOfDelivery,omitempty"`

	// Special instructions regarding the shipment. This field is for import purchase orders.
	ShippingInstructions string `json:"shippingInstructions,omitempty"`
}

// Validate validates this import details
func (m *ImportDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImportContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInternationalCommercialTerms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethodOfPayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortOfDelivery(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ImportDetails) validateImportContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportContainers) { // not required
		return nil
	}

	if err := validate.MaxLength("importContainers", "body", m.ImportContainers, 64); err != nil {
		return err
	}

	return nil
}

var importDetailsTypeInternationalCommercialTermsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ExWorks","FreeCarrier","FreeOnBoard","FreeAlongSideShip","CarriagePaidTo","CostAndFreight","CarriageAndInsurancePaidTo","CostInsuranceAndFreight","DeliveredAtTerminal","DeliveredAtPlace","DeliverDutyPaid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		importDetailsTypeInternationalCommercialTermsPropEnum = append(importDetailsTypeInternationalCommercialTermsPropEnum, v)
	}
}

const (

	// ImportDetailsInternationalCommercialTermsExWorks captures enum value "ExWorks"
	ImportDetailsInternationalCommercialTermsExWorks string = "ExWorks"

	// ImportDetailsInternationalCommercialTermsFreeCarrier captures enum value "FreeCarrier"
	ImportDetailsInternationalCommercialTermsFreeCarrier string = "FreeCarrier"

	// ImportDetailsInternationalCommercialTermsFreeOnBoard captures enum value "FreeOnBoard"
	ImportDetailsInternationalCommercialTermsFreeOnBoard string = "FreeOnBoard"

	// ImportDetailsInternationalCommercialTermsFreeAlongSideShip captures enum value "FreeAlongSideShip"
	ImportDetailsInternationalCommercialTermsFreeAlongSideShip string = "FreeAlongSideShip"

	// ImportDetailsInternationalCommercialTermsCarriagePaidTo captures enum value "CarriagePaidTo"
	ImportDetailsInternationalCommercialTermsCarriagePaidTo string = "CarriagePaidTo"

	// ImportDetailsInternationalCommercialTermsCostAndFreight captures enum value "CostAndFreight"
	ImportDetailsInternationalCommercialTermsCostAndFreight string = "CostAndFreight"

	// ImportDetailsInternationalCommercialTermsCarriageAndInsurancePaidTo captures enum value "CarriageAndInsurancePaidTo"
	ImportDetailsInternationalCommercialTermsCarriageAndInsurancePaidTo string = "CarriageAndInsurancePaidTo"

	// ImportDetailsInternationalCommercialTermsCostInsuranceAndFreight captures enum value "CostInsuranceAndFreight"
	ImportDetailsInternationalCommercialTermsCostInsuranceAndFreight string = "CostInsuranceAndFreight"

	// ImportDetailsInternationalCommercialTermsDeliveredAtTerminal captures enum value "DeliveredAtTerminal"
	ImportDetailsInternationalCommercialTermsDeliveredAtTerminal string = "DeliveredAtTerminal"

	// ImportDetailsInternationalCommercialTermsDeliveredAtPlace captures enum value "DeliveredAtPlace"
	ImportDetailsInternationalCommercialTermsDeliveredAtPlace string = "DeliveredAtPlace"

	// ImportDetailsInternationalCommercialTermsDeliverDutyPaid captures enum value "DeliverDutyPaid"
	ImportDetailsInternationalCommercialTermsDeliverDutyPaid string = "DeliverDutyPaid"
)

// prop value enum
func (m *ImportDetails) validateInternationalCommercialTermsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, importDetailsTypeInternationalCommercialTermsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ImportDetails) validateInternationalCommercialTerms(formats strfmt.Registry) error {
	if swag.IsZero(m.InternationalCommercialTerms) { // not required
		return nil
	}

	// value enum
	if err := m.validateInternationalCommercialTermsEnum("internationalCommercialTerms", "body", m.InternationalCommercialTerms); err != nil {
		return err
	}

	return nil
}

var importDetailsTypeMethodOfPaymentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PaidByBuyer","CollectOnDelivery","DefinedByBuyerAndSeller","FOBPortOfCall","PrepaidBySeller","PaidBySeller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		importDetailsTypeMethodOfPaymentPropEnum = append(importDetailsTypeMethodOfPaymentPropEnum, v)
	}
}

const (

	// ImportDetailsMethodOfPaymentPaidByBuyer captures enum value "PaidByBuyer"
	ImportDetailsMethodOfPaymentPaidByBuyer string = "PaidByBuyer"

	// ImportDetailsMethodOfPaymentCollectOnDelivery captures enum value "CollectOnDelivery"
	ImportDetailsMethodOfPaymentCollectOnDelivery string = "CollectOnDelivery"

	// ImportDetailsMethodOfPaymentDefinedByBuyerAndSeller captures enum value "DefinedByBuyerAndSeller"
	ImportDetailsMethodOfPaymentDefinedByBuyerAndSeller string = "DefinedByBuyerAndSeller"

	// ImportDetailsMethodOfPaymentFOBPortOfCall captures enum value "FOBPortOfCall"
	ImportDetailsMethodOfPaymentFOBPortOfCall string = "FOBPortOfCall"

	// ImportDetailsMethodOfPaymentPrepaidBySeller captures enum value "PrepaidBySeller"
	ImportDetailsMethodOfPaymentPrepaidBySeller string = "PrepaidBySeller"

	// ImportDetailsMethodOfPaymentPaidBySeller captures enum value "PaidBySeller"
	ImportDetailsMethodOfPaymentPaidBySeller string = "PaidBySeller"
)

// prop value enum
func (m *ImportDetails) validateMethodOfPaymentEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, importDetailsTypeMethodOfPaymentPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ImportDetails) validateMethodOfPayment(formats strfmt.Registry) error {
	if swag.IsZero(m.MethodOfPayment) { // not required
		return nil
	}

	// value enum
	if err := m.validateMethodOfPaymentEnum("methodOfPayment", "body", m.MethodOfPayment); err != nil {
		return err
	}

	return nil
}

func (m *ImportDetails) validatePortOfDelivery(formats strfmt.Registry) error {
	if swag.IsZero(m.PortOfDelivery) { // not required
		return nil
	}

	if err := validate.MaxLength("portOfDelivery", "body", m.PortOfDelivery, 64); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this import details based on context it is used
func (m *ImportDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ImportDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ImportDetails) UnmarshalBinary(b []byte) error {
	var res ImportDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
