// Code generated by go-swagger; DO NOT EDIT.

package product_pricing_2022_05_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Offer The offer data of a product.
//
// swagger:model Offer
type Offer struct {

	// Item Condition.
	// Required: true
	Condition *Condition `json:"condition"`

	// The fulfillment type for the offer. Possible values are AFN (Amazon Fulfillment Network) and MFN (Merchant Fulfillment Network).
	// Required: true
	FulfillmentType *FulfillmentType `json:"fulfillmentType"`

	// Offer buying price. Does not include shipping, points, or applicable promotions.
	// Required: true
	ListingPrice *MoneyType `json:"listingPrice"`

	// The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the Points element is only returned in Japan (JP).
	Points *Points `json:"points,omitempty"`

	// Amazon Prime details.
	PrimeDetails *PrimeDetails `json:"primeDetails,omitempty"`

	// The seller identifier for the offer.
	// Required: true
	SellerID *string `json:"sellerId"`

	// A list of shipping options associated with this offer
	ShippingOptions []*ShippingOption `json:"shippingOptions"`

	// The item subcondition for the offer.
	// Enum: [New Mint VeryGood Good Acceptable Poor Club OEM Warranty RefurbishedWarranty Refurbished OpenBox Other]
	SubCondition string `json:"subCondition,omitempty"`
}

// Validate validates this offer
func (m *Offer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFulfillmentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListingPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePoints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimeDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubCondition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Offer) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	if m.Condition != nil {
		if err := m.Condition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("condition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("condition")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateFulfillmentType(formats strfmt.Registry) error {

	if err := validate.Required("fulfillmentType", "body", m.FulfillmentType); err != nil {
		return err
	}

	if err := validate.Required("fulfillmentType", "body", m.FulfillmentType); err != nil {
		return err
	}

	if m.FulfillmentType != nil {
		if err := m.FulfillmentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fulfillmentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fulfillmentType")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateListingPrice(formats strfmt.Registry) error {

	if err := validate.Required("listingPrice", "body", m.ListingPrice); err != nil {
		return err
	}

	if m.ListingPrice != nil {
		if err := m.ListingPrice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("listingPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("listingPrice")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validatePoints(formats strfmt.Registry) error {
	if swag.IsZero(m.Points) { // not required
		return nil
	}

	if m.Points != nil {
		if err := m.Points.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("points")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("points")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validatePrimeDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.PrimeDetails) { // not required
		return nil
	}

	if m.PrimeDetails != nil {
		if err := m.PrimeDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primeDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primeDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateSellerID(formats strfmt.Registry) error {

	if err := validate.Required("sellerId", "body", m.SellerID); err != nil {
		return err
	}

	return nil
}

func (m *Offer) validateShippingOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.ShippingOptions); i++ {
		if swag.IsZero(m.ShippingOptions[i]) { // not required
			continue
		}

		if m.ShippingOptions[i] != nil {
			if err := m.ShippingOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var offerTypeSubConditionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["New","Mint","VeryGood","Good","Acceptable","Poor","Club","OEM","Warranty","RefurbishedWarranty","Refurbished","OpenBox","Other"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		offerTypeSubConditionPropEnum = append(offerTypeSubConditionPropEnum, v)
	}
}

const (

	// OfferSubConditionNew captures enum value "New"
	OfferSubConditionNew string = "New"

	// OfferSubConditionMint captures enum value "Mint"
	OfferSubConditionMint string = "Mint"

	// OfferSubConditionVeryGood captures enum value "VeryGood"
	OfferSubConditionVeryGood string = "VeryGood"

	// OfferSubConditionGood captures enum value "Good"
	OfferSubConditionGood string = "Good"

	// OfferSubConditionAcceptable captures enum value "Acceptable"
	OfferSubConditionAcceptable string = "Acceptable"

	// OfferSubConditionPoor captures enum value "Poor"
	OfferSubConditionPoor string = "Poor"

	// OfferSubConditionClub captures enum value "Club"
	OfferSubConditionClub string = "Club"

	// OfferSubConditionOEM captures enum value "OEM"
	OfferSubConditionOEM string = "OEM"

	// OfferSubConditionWarranty captures enum value "Warranty"
	OfferSubConditionWarranty string = "Warranty"

	// OfferSubConditionRefurbishedWarranty captures enum value "RefurbishedWarranty"
	OfferSubConditionRefurbishedWarranty string = "RefurbishedWarranty"

	// OfferSubConditionRefurbished captures enum value "Refurbished"
	OfferSubConditionRefurbished string = "Refurbished"

	// OfferSubConditionOpenBox captures enum value "OpenBox"
	OfferSubConditionOpenBox string = "OpenBox"

	// OfferSubConditionOther captures enum value "Other"
	OfferSubConditionOther string = "Other"
)

// prop value enum
func (m *Offer) validateSubConditionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, offerTypeSubConditionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Offer) validateSubCondition(formats strfmt.Registry) error {
	if swag.IsZero(m.SubCondition) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubConditionEnum("subCondition", "body", m.SubCondition); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this offer based on the context it is used
func (m *Offer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCondition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFulfillmentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateListingPrice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePoints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimeDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShippingOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Offer) contextValidateCondition(ctx context.Context, formats strfmt.Registry) error {

	if m.Condition != nil {
		if err := m.Condition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("condition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("condition")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateFulfillmentType(ctx context.Context, formats strfmt.Registry) error {

	if m.FulfillmentType != nil {
		if err := m.FulfillmentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fulfillmentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fulfillmentType")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateListingPrice(ctx context.Context, formats strfmt.Registry) error {

	if m.ListingPrice != nil {
		if err := m.ListingPrice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("listingPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("listingPrice")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidatePoints(ctx context.Context, formats strfmt.Registry) error {

	if m.Points != nil {
		if err := m.Points.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("points")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("points")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidatePrimeDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.PrimeDetails != nil {
		if err := m.PrimeDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primeDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primeDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateShippingOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ShippingOptions); i++ {

		if m.ShippingOptions[i] != nil {
			if err := m.ShippingOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Offer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Offer) UnmarshalBinary(b []byte) error {
	var res Offer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
