// Code generated by go-swagger; DO NOT EDIT.

package product_pricing_2022_05_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Offer The offer data of a product.
//
// swagger:model Offer
type Offer struct {

	// Item Condition.
	// Required: true
	Condition *Condition `json:"condition"`

	// The fulfillment type for the offer. Possible values are AFN (Amazon Fulfillment Network) and MFN (Merchant Fulfillment Network).
	// Required: true
	FulfillmentType *FulfillmentType `json:"fulfillmentType"`

	// Offer buying price. Does not include shipping, points, or applicable promotions.
	// Required: true
	ListingPrice *MoneyType `json:"listingPrice"`

	// The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the Points element is only returned in Japan (JP).
	Points *Points `json:"points,omitempty"`

	// The seller identifier for the offer.
	// Required: true
	SellerID *string `json:"sellerId"`

	// A list of shipping options associated with this offer
	ShippingOptions []*ShippingOption `json:"shippingOptions"`
}

// Validate validates this offer
func (m *Offer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFulfillmentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListingPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePoints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Offer) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	if m.Condition != nil {
		if err := m.Condition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("condition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("condition")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateFulfillmentType(formats strfmt.Registry) error {

	if err := validate.Required("fulfillmentType", "body", m.FulfillmentType); err != nil {
		return err
	}

	if err := validate.Required("fulfillmentType", "body", m.FulfillmentType); err != nil {
		return err
	}

	if m.FulfillmentType != nil {
		if err := m.FulfillmentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fulfillmentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fulfillmentType")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateListingPrice(formats strfmt.Registry) error {

	if err := validate.Required("listingPrice", "body", m.ListingPrice); err != nil {
		return err
	}

	if m.ListingPrice != nil {
		if err := m.ListingPrice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("listingPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("listingPrice")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validatePoints(formats strfmt.Registry) error {
	if swag.IsZero(m.Points) { // not required
		return nil
	}

	if m.Points != nil {
		if err := m.Points.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("points")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("points")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) validateSellerID(formats strfmt.Registry) error {

	if err := validate.Required("sellerId", "body", m.SellerID); err != nil {
		return err
	}

	return nil
}

func (m *Offer) validateShippingOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.ShippingOptions); i++ {
		if swag.IsZero(m.ShippingOptions[i]) { // not required
			continue
		}

		if m.ShippingOptions[i] != nil {
			if err := m.ShippingOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this offer based on the context it is used
func (m *Offer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCondition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFulfillmentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateListingPrice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePoints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShippingOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Offer) contextValidateCondition(ctx context.Context, formats strfmt.Registry) error {

	if m.Condition != nil {
		if err := m.Condition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("condition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("condition")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateFulfillmentType(ctx context.Context, formats strfmt.Registry) error {

	if m.FulfillmentType != nil {
		if err := m.FulfillmentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fulfillmentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fulfillmentType")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateListingPrice(ctx context.Context, formats strfmt.Registry) error {

	if m.ListingPrice != nil {
		if err := m.ListingPrice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("listingPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("listingPrice")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidatePoints(ctx context.Context, formats strfmt.Registry) error {

	if m.Points != nil {
		if err := m.Points.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("points")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("points")
			}
			return err
		}
	}

	return nil
}

func (m *Offer) contextValidateShippingOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ShippingOptions); i++ {

		if m.ShippingOptions[i] != nil {
			if err := m.ShippingOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shippingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Offer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Offer) UnmarshalBinary(b []byte) error {
	var res Offer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
