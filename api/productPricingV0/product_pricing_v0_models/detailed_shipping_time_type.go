// Code generated by go-swagger; DO NOT EDIT.

package product_pricing_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DetailedShippingTimeType The time range in which an item will likely be shipped once an order has been placed.
//
// swagger:model DetailedShippingTimeType
type DetailedShippingTimeType struct {

	// Indicates whether the item is available for shipping now, or on a known or an unknown date in the future. If known, the availableDate property indicates the date that the item will be available for shipping. Possible values: NOW, FUTURE_WITHOUT_DATE, FUTURE_WITH_DATE.
	// Enum: [NOW FUTURE_WITHOUT_DATE FUTURE_WITH_DATE]
	AvailabilityType string `json:"availabilityType,omitempty"`

	// The date when the item will be available for shipping. Only displayed for items that are not currently available for shipping.
	AvailableDate string `json:"availableDate,omitempty"`

	// The maximum time, in hours, that the item will likely be shipped after the order has been placed.
	MaximumHours int64 `json:"maximumHours,omitempty"`

	// The minimum time, in hours, that the item will likely be shipped after the order has been placed.
	MinimumHours int64 `json:"minimumHours,omitempty"`
}

// Validate validates this detailed shipping time type
func (m *DetailedShippingTimeType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var detailedShippingTimeTypeTypeAvailabilityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NOW","FUTURE_WITHOUT_DATE","FUTURE_WITH_DATE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		detailedShippingTimeTypeTypeAvailabilityTypePropEnum = append(detailedShippingTimeTypeTypeAvailabilityTypePropEnum, v)
	}
}

const (

	// DetailedShippingTimeTypeAvailabilityTypeNOW captures enum value "NOW"
	DetailedShippingTimeTypeAvailabilityTypeNOW string = "NOW"

	// DetailedShippingTimeTypeAvailabilityTypeFUTUREWITHOUTDATE captures enum value "FUTURE_WITHOUT_DATE"
	DetailedShippingTimeTypeAvailabilityTypeFUTUREWITHOUTDATE string = "FUTURE_WITHOUT_DATE"

	// DetailedShippingTimeTypeAvailabilityTypeFUTUREWITHDATE captures enum value "FUTURE_WITH_DATE"
	DetailedShippingTimeTypeAvailabilityTypeFUTUREWITHDATE string = "FUTURE_WITH_DATE"
)

// prop value enum
func (m *DetailedShippingTimeType) validateAvailabilityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, detailedShippingTimeTypeTypeAvailabilityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DetailedShippingTimeType) validateAvailabilityType(formats strfmt.Registry) error {
	if swag.IsZero(m.AvailabilityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAvailabilityTypeEnum("availabilityType", "body", m.AvailabilityType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this detailed shipping time type based on context it is used
func (m *DetailedShippingTimeType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DetailedShippingTimeType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DetailedShippingTimeType) UnmarshalBinary(b []byte) error {
	var res DetailedShippingTimeType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
