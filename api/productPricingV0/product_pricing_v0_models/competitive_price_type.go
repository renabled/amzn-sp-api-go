// Code generated by go-swagger; DO NOT EDIT.

package product_pricing_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CompetitivePriceType competitive price type
//
// swagger:model CompetitivePriceType
type CompetitivePriceType struct {

	// The pricing model for each price that is returned.
	//
	// Possible values:
	//
	// * 1 - New Buy Box Price.
	// * 2 - Used Buy Box Price.
	// Required: true
	CompetitivePriceID *string `json:"CompetitivePriceId"`

	// Pricing information for a given CompetitivePriceId value.
	// Required: true
	Price *PriceType `json:"Price"`

	//  Indicates whether or not the pricing information is for an offer listing that belongs to the requester. The requester is the seller associated with the SellerId that was submitted with the request. Possible values are: true and false.
	BelongsToRequester bool `json:"belongsToRequester,omitempty"`

	// Indicates the condition of the item whose pricing information is returned. Possible values are: New, Used, Collectible, Refurbished, or Club.
	Condition string `json:"condition,omitempty"`

	// Indicates the type of customer that the offer is valid for.<br><br>When the offer type is B2C in a quantity discount, the seller is winning the Buy Box because others do not have inventory at that quantity, not because they have a quantity discount on the ASIN.
	OfferType OfferCustomerType `json:"offerType,omitempty"`

	// Indicates the type of quantity discount this price applies to.
	QuantityDiscountType QuantityDiscountType `json:"quantityDiscountType,omitempty"`

	// Indicates at what quantity this price becomes active.
	QuantityTier int32 `json:"quantityTier,omitempty"`

	// The seller identifier for the offer.
	SellerID string `json:"sellerId,omitempty"`

	// Indicates the subcondition of the item whose pricing information is returned. Possible values are: New, Mint, Very Good, Good, Acceptable, Poor, Club, OEM, Warranty, Refurbished Warranty, Refurbished, Open Box, or Other.
	Subcondition string `json:"subcondition,omitempty"`
}

// Validate validates this competitive price type
func (m *CompetitivePriceType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompetitivePriceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOfferType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantityDiscountType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CompetitivePriceType) validateCompetitivePriceID(formats strfmt.Registry) error {

	if err := validate.Required("CompetitivePriceId", "body", m.CompetitivePriceID); err != nil {
		return err
	}

	return nil
}

func (m *CompetitivePriceType) validatePrice(formats strfmt.Registry) error {

	if err := validate.Required("Price", "body", m.Price); err != nil {
		return err
	}

	if m.Price != nil {
		if err := m.Price.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Price")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Price")
			}
			return err
		}
	}

	return nil
}

func (m *CompetitivePriceType) validateOfferType(formats strfmt.Registry) error {
	if swag.IsZero(m.OfferType) { // not required
		return nil
	}

	if err := m.OfferType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("offerType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("offerType")
		}
		return err
	}

	return nil
}

func (m *CompetitivePriceType) validateQuantityDiscountType(formats strfmt.Registry) error {
	if swag.IsZero(m.QuantityDiscountType) { // not required
		return nil
	}

	if err := m.QuantityDiscountType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("quantityDiscountType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("quantityDiscountType")
		}
		return err
	}

	return nil
}

// ContextValidate validate this competitive price type based on the context it is used
func (m *CompetitivePriceType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePrice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOfferType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuantityDiscountType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CompetitivePriceType) contextValidatePrice(ctx context.Context, formats strfmt.Registry) error {

	if m.Price != nil {
		if err := m.Price.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Price")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Price")
			}
			return err
		}
	}

	return nil
}

func (m *CompetitivePriceType) contextValidateOfferType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.OfferType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("offerType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("offerType")
		}
		return err
	}

	return nil
}

func (m *CompetitivePriceType) contextValidateQuantityDiscountType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.QuantityDiscountType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("quantityDiscountType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("quantityDiscountType")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CompetitivePriceType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CompetitivePriceType) UnmarshalBinary(b []byte) error {
	var res CompetitivePriceType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
