// Code generated by go-swagger; DO NOT EDIT.

package vendor_invoices_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Invoice invoice
//
// swagger:model Invoice
type Invoice struct {

	// Additional details provided by the selling party, for tax related or other purposes.
	AdditionalDetails []*AdditionalDetails `json:"additionalDetails"`

	// Total allowance amount details for all line items.
	AllowanceDetails []*AllowanceDetails `json:"allowanceDetails"`

	// Name, address and tax details of the party to whom this invoice is issued.
	BillToParty *PartyIdentification `json:"billToParty,omitempty"`

	// Total charge amount details for all line items.
	ChargeDetails []*ChargeDetails `json:"chargeDetails"`

	// Date when the invoice/credit note information was generated in the origin's accounting system. The invoice date should be on or after the purchase order creation date.
	// Required: true
	// Format: date-time
	Date *DateTime `json:"date"`

	// Unique number relating to the charges defined in this document. This will be invoice number if the document type is Invoice or CreditNote number if the document type is Credit Note. Failure to provide this reference will result in a rejection.
	// Required: true
	ID *string `json:"id"`

	// Total monetary amount charged in the invoice or full value of credit note to be paid including all relevant taxes. It is the total amount of invoice (including charges, less allowances) before terms discount (if discount is applicable).
	// Required: true
	InvoiceTotal *Money `json:"invoiceTotal"`

	// Identifies the type of invoice.
	// Required: true
	// Enum: [Invoice CreditNote]
	InvoiceType *string `json:"invoiceType"`

	// The list of invoice items.
	Items []*InvoiceItem `json:"items"`

	// The payment terms for the invoice.
	PaymentTerms *PaymentTerms `json:"paymentTerms,omitempty"`

	// An additional unique reference number used for regulatory or other purposes.
	ReferenceNumber string `json:"referenceNumber,omitempty"`

	// Name, address and tax details of the party receiving the payment of this invoice.
	// Required: true
	RemitToParty *PartyIdentification `json:"remitToParty"`

	// Name, address and tax details of the party sending a shipment of products.
	ShipFromParty *PartyIdentification `json:"shipFromParty,omitempty"`

	// Name, address and tax details of the party receiving a shipment of products.
	ShipToParty *PartyIdentification `json:"shipToParty,omitempty"`

	// Total tax amount details for all line items.
	TaxDetails []*TaxDetails `json:"taxDetails"`
}

// Validate validates this invoice
func (m *Invoice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowanceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillToParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChargeDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoiceTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoiceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentTerms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemitToParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipFromParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipToParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) validateAdditionalDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.AdditionalDetails); i++ {
		if swag.IsZero(m.AdditionalDetails[i]) { // not required
			continue
		}

		if m.AdditionalDetails[i] != nil {
			if err := m.AdditionalDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("additionalDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("additionalDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) validateAllowanceDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowanceDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowanceDetails); i++ {
		if swag.IsZero(m.AllowanceDetails[i]) { // not required
			continue
		}

		if m.AllowanceDetails[i] != nil {
			if err := m.AllowanceDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("allowanceDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("allowanceDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) validateBillToParty(formats strfmt.Registry) error {
	if swag.IsZero(m.BillToParty) { // not required
		return nil
	}

	if m.BillToParty != nil {
		if err := m.BillToParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateChargeDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ChargeDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.ChargeDetails); i++ {
		if swag.IsZero(m.ChargeDetails[i]) { // not required
			continue
		}

		if m.ChargeDetails[i] != nil {
			if err := m.ChargeDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("chargeDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("chargeDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) validateDate(formats strfmt.Registry) error {

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	if m.Date != nil {
		if err := m.Date.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("date")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("date")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateInvoiceTotal(formats strfmt.Registry) error {

	if err := validate.Required("invoiceTotal", "body", m.InvoiceTotal); err != nil {
		return err
	}

	if m.InvoiceTotal != nil {
		if err := m.InvoiceTotal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("invoiceTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("invoiceTotal")
			}
			return err
		}
	}

	return nil
}

var invoiceTypeInvoiceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Invoice","CreditNote"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		invoiceTypeInvoiceTypePropEnum = append(invoiceTypeInvoiceTypePropEnum, v)
	}
}

const (

	// InvoiceInvoiceTypeInvoice captures enum value "Invoice"
	InvoiceInvoiceTypeInvoice string = "Invoice"

	// InvoiceInvoiceTypeCreditNote captures enum value "CreditNote"
	InvoiceInvoiceTypeCreditNote string = "CreditNote"
)

// prop value enum
func (m *Invoice) validateInvoiceTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, invoiceTypeInvoiceTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) validateInvoiceType(formats strfmt.Registry) error {

	if err := validate.Required("invoiceType", "body", m.InvoiceType); err != nil {
		return err
	}

	// value enum
	if err := m.validateInvoiceTypeEnum("invoiceType", "body", *m.InvoiceType); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateItems(formats strfmt.Registry) error {
	if swag.IsZero(m.Items) { // not required
		return nil
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) validatePaymentTerms(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentTerms) { // not required
		return nil
	}

	if m.PaymentTerms != nil {
		if err := m.PaymentTerms.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paymentTerms")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paymentTerms")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateRemitToParty(formats strfmt.Registry) error {

	if err := validate.Required("remitToParty", "body", m.RemitToParty); err != nil {
		return err
	}

	if m.RemitToParty != nil {
		if err := m.RemitToParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remitToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remitToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateShipFromParty(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipFromParty) { // not required
		return nil
	}

	if m.ShipFromParty != nil {
		if err := m.ShipFromParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipFromParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipFromParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateShipToParty(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipToParty) { // not required
		return nil
	}

	if m.ShipToParty != nil {
		if err := m.ShipToParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.TaxDetails); i++ {
		if swag.IsZero(m.TaxDetails[i]) { // not required
			continue
		}

		if m.TaxDetails[i] != nil {
			if err := m.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this invoice based on the context it is used
func (m *Invoice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdditionalDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAllowanceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBillToParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChargeDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInvoiceTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentTerms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemitToParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipFromParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipToParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) contextValidateAdditionalDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AdditionalDetails); i++ {

		if m.AdditionalDetails[i] != nil {
			if err := m.AdditionalDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("additionalDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("additionalDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) contextValidateAllowanceDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AllowanceDetails); i++ {

		if m.AllowanceDetails[i] != nil {
			if err := m.AllowanceDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("allowanceDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("allowanceDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) contextValidateBillToParty(ctx context.Context, formats strfmt.Registry) error {

	if m.BillToParty != nil {
		if err := m.BillToParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateChargeDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ChargeDetails); i++ {

		if m.ChargeDetails[i] != nil {
			if err := m.ChargeDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("chargeDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("chargeDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) contextValidateDate(ctx context.Context, formats strfmt.Registry) error {

	if m.Date != nil {
		if err := m.Date.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("date")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("date")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateInvoiceTotal(ctx context.Context, formats strfmt.Registry) error {

	if m.InvoiceTotal != nil {
		if err := m.InvoiceTotal.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("invoiceTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("invoiceTotal")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Invoice) contextValidatePaymentTerms(ctx context.Context, formats strfmt.Registry) error {

	if m.PaymentTerms != nil {
		if err := m.PaymentTerms.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paymentTerms")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paymentTerms")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateRemitToParty(ctx context.Context, formats strfmt.Registry) error {

	if m.RemitToParty != nil {
		if err := m.RemitToParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remitToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remitToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateShipFromParty(ctx context.Context, formats strfmt.Registry) error {

	if m.ShipFromParty != nil {
		if err := m.ShipFromParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipFromParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipFromParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateShipToParty(ctx context.Context, formats strfmt.Registry) error {

	if m.ShipToParty != nil {
		if err := m.ShipToParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Invoice) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaxDetails); i++ {

		if m.TaxDetails[i] != nil {
			if err := m.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Invoice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Invoice) UnmarshalBinary(b []byte) error {
	var res Invoice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
