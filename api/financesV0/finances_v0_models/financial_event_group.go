// Code generated by go-swagger; DO NOT EDIT.

package finances_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FinancialEventGroup Information related to a financial event group.
//
// swagger:model FinancialEventGroup
type FinancialEventGroup struct {

	// The account tail of the payment instrument.
	AccountTail string `json:"AccountTail,omitempty"`

	// The balance at the start of the settlement period.
	BeginningBalance *Currency `json:"BeginningBalance,omitempty"`

	// The total amount in the currency of the marketplace in which the funds were disbursed.
	ConvertedTotal *Currency `json:"ConvertedTotal,omitempty"`

	// The date and time at which the financial event group is closed. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	// Format: date-time
	FinancialEventGroupEnd Date `json:"FinancialEventGroupEnd,omitempty"`

	// A unique identifier for the financial event group.
	FinancialEventGroupID string `json:"FinancialEventGroupId,omitempty"`

	// The date and time at which the financial event group is opened. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	// Format: date-time
	FinancialEventGroupStart Date `json:"FinancialEventGroupStart,omitempty"`

	// The date and time when the disbursement or charge was initiated. Only present for closed settlements. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	// Format: date-time
	FundTransferDate Date `json:"FundTransferDate,omitempty"`

	// The status of the fund transfer.
	FundTransferStatus string `json:"FundTransferStatus,omitempty"`

	// The total amount in the currency of the marketplace in which the transactions occurred. For a closed financial group, this is the total amount of a disbursement or a charge amount. For an open financial event group, this is the current balance.
	OriginalTotal *Currency `json:"OriginalTotal,omitempty"`

	// The processing status of the financial event group indicates whether the balance of the financial event group is settled.
	//
	// Possible values:
	//
	// * `Open`
	// * `Closed`
	ProcessingStatus string `json:"ProcessingStatus,omitempty"`

	// The trace identifier used by sellers to look up transactions externally.
	TraceID string `json:"TraceId,omitempty"`
}

// Validate validates this financial event group
func (m *FinancialEventGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBeginningBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConvertedTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinancialEventGroupEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinancialEventGroupStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFundTransferDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalTotal(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FinancialEventGroup) validateBeginningBalance(formats strfmt.Registry) error {
	if swag.IsZero(m.BeginningBalance) { // not required
		return nil
	}

	if m.BeginningBalance != nil {
		if err := m.BeginningBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("BeginningBalance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("BeginningBalance")
			}
			return err
		}
	}

	return nil
}

func (m *FinancialEventGroup) validateConvertedTotal(formats strfmt.Registry) error {
	if swag.IsZero(m.ConvertedTotal) { // not required
		return nil
	}

	if m.ConvertedTotal != nil {
		if err := m.ConvertedTotal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ConvertedTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ConvertedTotal")
			}
			return err
		}
	}

	return nil
}

func (m *FinancialEventGroup) validateFinancialEventGroupEnd(formats strfmt.Registry) error {
	if swag.IsZero(m.FinancialEventGroupEnd) { // not required
		return nil
	}

	if err := m.FinancialEventGroupEnd.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FinancialEventGroupEnd")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FinancialEventGroupEnd")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) validateFinancialEventGroupStart(formats strfmt.Registry) error {
	if swag.IsZero(m.FinancialEventGroupStart) { // not required
		return nil
	}

	if err := m.FinancialEventGroupStart.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FinancialEventGroupStart")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FinancialEventGroupStart")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) validateFundTransferDate(formats strfmt.Registry) error {
	if swag.IsZero(m.FundTransferDate) { // not required
		return nil
	}

	if err := m.FundTransferDate.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FundTransferDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FundTransferDate")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) validateOriginalTotal(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginalTotal) { // not required
		return nil
	}

	if m.OriginalTotal != nil {
		if err := m.OriginalTotal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("OriginalTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("OriginalTotal")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this financial event group based on the context it is used
func (m *FinancialEventGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBeginningBalance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConvertedTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinancialEventGroupEnd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinancialEventGroupStart(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFundTransferDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginalTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FinancialEventGroup) contextValidateBeginningBalance(ctx context.Context, formats strfmt.Registry) error {

	if m.BeginningBalance != nil {
		if err := m.BeginningBalance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("BeginningBalance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("BeginningBalance")
			}
			return err
		}
	}

	return nil
}

func (m *FinancialEventGroup) contextValidateConvertedTotal(ctx context.Context, formats strfmt.Registry) error {

	if m.ConvertedTotal != nil {
		if err := m.ConvertedTotal.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ConvertedTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ConvertedTotal")
			}
			return err
		}
	}

	return nil
}

func (m *FinancialEventGroup) contextValidateFinancialEventGroupEnd(ctx context.Context, formats strfmt.Registry) error {

	if err := m.FinancialEventGroupEnd.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FinancialEventGroupEnd")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FinancialEventGroupEnd")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) contextValidateFinancialEventGroupStart(ctx context.Context, formats strfmt.Registry) error {

	if err := m.FinancialEventGroupStart.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FinancialEventGroupStart")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FinancialEventGroupStart")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) contextValidateFundTransferDate(ctx context.Context, formats strfmt.Registry) error {

	if err := m.FundTransferDate.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("FundTransferDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("FundTransferDate")
		}
		return err
	}

	return nil
}

func (m *FinancialEventGroup) contextValidateOriginalTotal(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginalTotal != nil {
		if err := m.OriginalTotal.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("OriginalTotal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("OriginalTotal")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FinancialEventGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FinancialEventGroup) UnmarshalBinary(b []byte) error {
	var res FinancialEventGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
