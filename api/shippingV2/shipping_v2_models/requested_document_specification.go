// Code generated by go-swagger; DO NOT EDIT.

package shipping_v2_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RequestedDocumentSpecification The document specifications requested. For calls to the purchaseShipment operation, the shipment purchase fails if the specified document specifications are not among those returned in the response to the getRates operation.
//
// swagger:model RequestedDocumentSpecification
type RequestedDocumentSpecification struct {

	// dpi
	Dpi Dpi `json:"dpi,omitempty"`

	// format
	// Required: true
	Format *DocumentFormat `json:"format"`

	// need file joining
	// Required: true
	NeedFileJoining *NeedFileJoining `json:"needFileJoining"`

	// page layout
	PageLayout PageLayout `json:"pageLayout,omitempty"`

	// A list of the document types requested.
	// Required: true
	RequestedDocumentTypes []DocumentType `json:"requestedDocumentTypes"`

	// size
	// Required: true
	Size *DocumentSize `json:"size"`
}

// Validate validates this requested document specification
func (m *RequestedDocumentSpecification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDpi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNeedFileJoining(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageLayout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestedDocumentTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RequestedDocumentSpecification) validateDpi(formats strfmt.Registry) error {
	if swag.IsZero(m.Dpi) { // not required
		return nil
	}

	if err := m.Dpi.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dpi")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("dpi")
		}
		return err
	}

	return nil
}

func (m *RequestedDocumentSpecification) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("format", "body", m.Format); err != nil {
		return err
	}

	if err := validate.Required("format", "body", m.Format); err != nil {
		return err
	}

	if m.Format != nil {
		if err := m.Format.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("format")
			}
			return err
		}
	}

	return nil
}

func (m *RequestedDocumentSpecification) validateNeedFileJoining(formats strfmt.Registry) error {

	if err := validate.Required("needFileJoining", "body", m.NeedFileJoining); err != nil {
		return err
	}

	if err := validate.Required("needFileJoining", "body", m.NeedFileJoining); err != nil {
		return err
	}

	if m.NeedFileJoining != nil {
		if err := m.NeedFileJoining.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("needFileJoining")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("needFileJoining")
			}
			return err
		}
	}

	return nil
}

func (m *RequestedDocumentSpecification) validatePageLayout(formats strfmt.Registry) error {
	if swag.IsZero(m.PageLayout) { // not required
		return nil
	}

	if err := m.PageLayout.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("pageLayout")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("pageLayout")
		}
		return err
	}

	return nil
}

func (m *RequestedDocumentSpecification) validateRequestedDocumentTypes(formats strfmt.Registry) error {

	if err := validate.Required("requestedDocumentTypes", "body", m.RequestedDocumentTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.RequestedDocumentTypes); i++ {

		if err := m.RequestedDocumentTypes[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requestedDocumentTypes" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("requestedDocumentTypes" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *RequestedDocumentSpecification) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	if m.Size != nil {
		if err := m.Size.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this requested document specification based on the context it is used
func (m *RequestedDocumentSpecification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDpi(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNeedFileJoining(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePageLayout(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRequestedDocumentTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RequestedDocumentSpecification) contextValidateDpi(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Dpi.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dpi")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("dpi")
		}
		return err
	}

	return nil
}

func (m *RequestedDocumentSpecification) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if m.Format != nil {
		if err := m.Format.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("format")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("format")
			}
			return err
		}
	}

	return nil
}

func (m *RequestedDocumentSpecification) contextValidateNeedFileJoining(ctx context.Context, formats strfmt.Registry) error {

	if m.NeedFileJoining != nil {
		if err := m.NeedFileJoining.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("needFileJoining")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("needFileJoining")
			}
			return err
		}
	}

	return nil
}

func (m *RequestedDocumentSpecification) contextValidatePageLayout(ctx context.Context, formats strfmt.Registry) error {

	if err := m.PageLayout.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("pageLayout")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("pageLayout")
		}
		return err
	}

	return nil
}

func (m *RequestedDocumentSpecification) contextValidateRequestedDocumentTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RequestedDocumentTypes); i++ {

		if err := m.RequestedDocumentTypes[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requestedDocumentTypes" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("requestedDocumentTypes" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *RequestedDocumentSpecification) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if m.Size != nil {
		if err := m.Size.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RequestedDocumentSpecification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RequestedDocumentSpecification) UnmarshalBinary(b []byte) error {
	var res RequestedDocumentSpecification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
