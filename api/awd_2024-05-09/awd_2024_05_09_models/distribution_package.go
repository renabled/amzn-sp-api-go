// Code generated by go-swagger; DO NOT EDIT.

package awd_2024_05_09_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DistributionPackage Represents an AWD distribution package.
// Example: {"contents":{"products":[{"quantity":1,"sku":"testPen"}]},"measurements":{"dimensions":{"height":1,"length":1,"unitOfMeasurement":"INCHES","width":1},"volume":{"unitOfMeasurement":"CUIN","volume":1},"weight":{"unitOfMeasurement":"POUNDS","weight":1}},"type":"CASE"}
//
// swagger:model DistributionPackage
type DistributionPackage struct {

	// The contents appropriate for the type.
	// Required: true
	Contents *DistributionPackageContents `json:"contents"`

	// Measurements of a package, including weight, volume, and dimensions.
	// Required: true
	Measurements *MeasurementData `json:"measurements"`

	// Type of distribution package.
	// Required: true
	Type *DistributionPackageType `json:"type"`
}

// Validate validates this distribution package
func (m *DistributionPackage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeasurements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DistributionPackage) validateContents(formats strfmt.Registry) error {

	if err := validate.Required("contents", "body", m.Contents); err != nil {
		return err
	}

	if m.Contents != nil {
		if err := m.Contents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contents")
			}
			return err
		}
	}

	return nil
}

func (m *DistributionPackage) validateMeasurements(formats strfmt.Registry) error {

	if err := validate.Required("measurements", "body", m.Measurements); err != nil {
		return err
	}

	if m.Measurements != nil {
		if err := m.Measurements.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("measurements")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("measurements")
			}
			return err
		}
	}

	return nil
}

func (m *DistributionPackage) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this distribution package based on the context it is used
func (m *DistributionPackage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMeasurements(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DistributionPackage) contextValidateContents(ctx context.Context, formats strfmt.Registry) error {

	if m.Contents != nil {
		if err := m.Contents.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contents")
			}
			return err
		}
	}

	return nil
}

func (m *DistributionPackage) contextValidateMeasurements(ctx context.Context, formats strfmt.Registry) error {

	if m.Measurements != nil {
		if err := m.Measurements.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("measurements")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("measurements")
			}
			return err
		}
	}

	return nil
}

func (m *DistributionPackage) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DistributionPackage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DistributionPackage) UnmarshalBinary(b []byte) error {
	var res DistributionPackage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
