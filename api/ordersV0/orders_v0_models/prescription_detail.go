// Code generated by go-swagger; DO NOT EDIT.

package orders_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrescriptionDetail Information about the prescription that is used to verify a regulated product. This must be provided once per order and reflect the sellerâ€™s own records. Only approved orders can have prescriptions.
//
// swagger:model PrescriptionDetail
type PrescriptionDetail struct {

	// The identifier for the clinic which provided the prescription used to verify the regulated product.
	// Required: true
	ClinicID *string `json:"clinicId"`

	// The expiration date of the prescription used to verify the regulated product, in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format.
	// Required: true
	// Format: date-time
	ExpirationDate *strfmt.DateTime `json:"expirationDate"`

	// The identifier for the prescription used to verify the regulated product.
	// Required: true
	PrescriptionID *string `json:"prescriptionId"`

	// The number of refills remaining for the prescription used to verify the regulated product. If a prescription originally had 10 total refills, this value must be `10` for the first order, `9` for the second order, and `0` for the eleventh order. If a prescription originally had no refills, this value must be 0.
	// Required: true
	// Minimum: 0
	RefillsRemaining *int64 `json:"refillsRemaining"`

	// The total number of refills written in the original prescription used to verify the regulated product. If a prescription originally had no refills, this value must be 0.
	// Required: true
	// Minimum: 0
	TotalRefillsAuthorized *int64 `json:"totalRefillsAuthorized"`

	// The instructions for the prescription as provided by the approver of the regulated product.
	// Required: true
	UsageInstructions *string `json:"usageInstructions"`

	// The number of units in each fill as provided in the prescription.
	// Required: true
	// Minimum: 1
	WrittenQuantity *int64 `json:"writtenQuantity"`
}

// Validate validates this prescription detail
func (m *PrescriptionDetail) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClinicID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrescriptionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefillsRemaining(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalRefillsAuthorized(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsageInstructions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWrittenQuantity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrescriptionDetail) validateClinicID(formats strfmt.Registry) error {

	if err := validate.Required("clinicId", "body", m.ClinicID); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validateExpirationDate(formats strfmt.Registry) error {

	if err := validate.Required("expirationDate", "body", m.ExpirationDate); err != nil {
		return err
	}

	if err := validate.FormatOf("expirationDate", "body", "date-time", m.ExpirationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validatePrescriptionID(formats strfmt.Registry) error {

	if err := validate.Required("prescriptionId", "body", m.PrescriptionID); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validateRefillsRemaining(formats strfmt.Registry) error {

	if err := validate.Required("refillsRemaining", "body", m.RefillsRemaining); err != nil {
		return err
	}

	if err := validate.MinimumInt("refillsRemaining", "body", *m.RefillsRemaining, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validateTotalRefillsAuthorized(formats strfmt.Registry) error {

	if err := validate.Required("totalRefillsAuthorized", "body", m.TotalRefillsAuthorized); err != nil {
		return err
	}

	if err := validate.MinimumInt("totalRefillsAuthorized", "body", *m.TotalRefillsAuthorized, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validateUsageInstructions(formats strfmt.Registry) error {

	if err := validate.Required("usageInstructions", "body", m.UsageInstructions); err != nil {
		return err
	}

	return nil
}

func (m *PrescriptionDetail) validateWrittenQuantity(formats strfmt.Registry) error {

	if err := validate.Required("writtenQuantity", "body", m.WrittenQuantity); err != nil {
		return err
	}

	if err := validate.MinimumInt("writtenQuantity", "body", *m.WrittenQuantity, 1, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this prescription detail based on context it is used
func (m *PrescriptionDetail) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PrescriptionDetail) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrescriptionDetail) UnmarshalBinary(b []byte) error {
	var res PrescriptionDetail
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
