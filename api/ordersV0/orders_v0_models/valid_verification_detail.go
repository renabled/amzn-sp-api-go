// Code generated by go-swagger; DO NOT EDIT.

package orders_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ValidVerificationDetail The types of verification details that may be provided for the order and the criteria required for when the type of verification detail can be provided. The types of verification details allowed depend on the type of regulated product and will not change order to order.
//
// swagger:model ValidVerificationDetail
type ValidVerificationDetail struct {

	// A list of valid verification statuses where the associated verification detail type may be provided. For example, if the value of this field is ["Approved"], calls to provide the associated verification detail will fail for orders with a `VerificationStatus` of `Pending`, `Rejected`, `Expired`, or `Cancelled`.
	// Required: true
	ValidVerificationStatuses []VerificationStatus `json:"ValidVerificationStatuses"`

	// A supported type of verification detail. The type indicates which verification detail could be shared while updating the regulated order. Valid value: `prescriptionDetail`.
	// Required: true
	VerificationDetailType *string `json:"VerificationDetailType"`
}

// Validate validates this valid verification detail
func (m *ValidVerificationDetail) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateValidVerificationStatuses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerificationDetailType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ValidVerificationDetail) validateValidVerificationStatuses(formats strfmt.Registry) error {

	if err := validate.Required("ValidVerificationStatuses", "body", m.ValidVerificationStatuses); err != nil {
		return err
	}

	for i := 0; i < len(m.ValidVerificationStatuses); i++ {

		if err := m.ValidVerificationStatuses[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValidVerificationStatuses" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValidVerificationStatuses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *ValidVerificationDetail) validateVerificationDetailType(formats strfmt.Registry) error {

	if err := validate.Required("VerificationDetailType", "body", m.VerificationDetailType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this valid verification detail based on the context it is used
func (m *ValidVerificationDetail) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateValidVerificationStatuses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ValidVerificationDetail) contextValidateValidVerificationStatuses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ValidVerificationStatuses); i++ {

		if err := m.ValidVerificationStatuses[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValidVerificationStatuses" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValidVerificationStatuses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ValidVerificationDetail) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ValidVerificationDetail) UnmarshalBinary(b []byte) error {
	var res ValidVerificationDetail
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
