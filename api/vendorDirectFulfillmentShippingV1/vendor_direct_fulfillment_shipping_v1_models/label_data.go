// Code generated by go-swagger; DO NOT EDIT.

package vendor_direct_fulfillment_shipping_v1_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LabelData Details of the shipment label.
//
// swagger:model LabelData
type LabelData struct {

	// This field will contain the Base64encoded string of the shipment label content.
	// Required: true
	Content *string `json:"content"`

	// Identifier for the package. The first package will be 001, the second 002, and so on. This number is used as a reference to refer to this package from the pallet level.
	PackageIdentifier string `json:"packageIdentifier,omitempty"`

	// Ship method to be used for shipping the order. Amazon defines ship method codes indicating shipping carrier and shipment service level. Ship method codes are case and format sensitive. The same ship method code should returned on the shipment confirmation. Note that the ship method codes are vendor specific and will be provided to each vendor during the implementation.
	ShipMethod string `json:"shipMethod,omitempty"`

	// Shipping method name for internal reference.
	ShipMethodName string `json:"shipMethodName,omitempty"`

	// Package tracking identifier from the shipping carrier.
	TrackingNumber string `json:"trackingNumber,omitempty"`
}

// Validate validates this label data
func (m *LabelData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LabelData) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", m.Content); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this label data based on context it is used
func (m *LabelData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LabelData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LabelData) UnmarshalBinary(b []byte) error {
	var res LabelData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
