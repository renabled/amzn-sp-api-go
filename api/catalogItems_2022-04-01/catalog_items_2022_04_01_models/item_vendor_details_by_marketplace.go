// Code generated by go-swagger; DO NOT EDIT.

package catalog_items_2022_04_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ItemVendorDetailsByMarketplace Vendor details associated with an Amazon catalog item for the indicated Amazon marketplace.
//
// swagger:model ItemVendorDetailsByMarketplace
type ItemVendorDetailsByMarketplace struct {

	// Brand code associated with an Amazon catalog item.
	BrandCode string `json:"brandCode,omitempty"`

	// Manufacturer code associated with an Amazon catalog item.
	ManufacturerCode string `json:"manufacturerCode,omitempty"`

	// Parent vendor code of the manufacturer code.
	ManufacturerCodeParent string `json:"manufacturerCodeParent,omitempty"`

	// Amazon marketplace identifier.
	// Required: true
	MarketplaceID *string `json:"marketplaceId"`

	// Product category associated with an Amazon catalog item.
	ProductCategory *ItemVendorDetailsCategory `json:"productCategory,omitempty"`

	// Product group associated with an Amazon catalog item.
	ProductGroup string `json:"productGroup,omitempty"`

	// Product subcategory associated with an Amazon catalog item.
	ProductSubcategory *ItemVendorDetailsCategory `json:"productSubcategory,omitempty"`

	// Replenishment category associated with an Amazon catalog item.
	// Enum: [ALLOCATED BASIC_REPLENISHMENT IN_SEASON LIMITED_REPLENISHMENT MANUFACTURER_OUT_OF_STOCK NEW_PRODUCT NON_REPLENISHABLE NON_STOCKUPABLE OBSOLETE PLANNED_REPLENISHMENT]
	ReplenishmentCategory string `json:"replenishmentCategory,omitempty"`
}

// Validate validates this item vendor details by marketplace
func (m *ItemVendorDetailsByMarketplace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMarketplaceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductSubcategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplenishmentCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ItemVendorDetailsByMarketplace) validateMarketplaceID(formats strfmt.Registry) error {

	if err := validate.Required("marketplaceId", "body", m.MarketplaceID); err != nil {
		return err
	}

	return nil
}

func (m *ItemVendorDetailsByMarketplace) validateProductCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.ProductCategory) { // not required
		return nil
	}

	if m.ProductCategory != nil {
		if err := m.ProductCategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

func (m *ItemVendorDetailsByMarketplace) validateProductSubcategory(formats strfmt.Registry) error {
	if swag.IsZero(m.ProductSubcategory) { // not required
		return nil
	}

	if m.ProductSubcategory != nil {
		if err := m.ProductSubcategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productSubcategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productSubcategory")
			}
			return err
		}
	}

	return nil
}

var itemVendorDetailsByMarketplaceTypeReplenishmentCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALLOCATED","BASIC_REPLENISHMENT","IN_SEASON","LIMITED_REPLENISHMENT","MANUFACTURER_OUT_OF_STOCK","NEW_PRODUCT","NON_REPLENISHABLE","NON_STOCKUPABLE","OBSOLETE","PLANNED_REPLENISHMENT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		itemVendorDetailsByMarketplaceTypeReplenishmentCategoryPropEnum = append(itemVendorDetailsByMarketplaceTypeReplenishmentCategoryPropEnum, v)
	}
}

const (

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryALLOCATED captures enum value "ALLOCATED"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryALLOCATED string = "ALLOCATED"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryBASICREPLENISHMENT captures enum value "BASIC_REPLENISHMENT"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryBASICREPLENISHMENT string = "BASIC_REPLENISHMENT"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryINSEASON captures enum value "IN_SEASON"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryINSEASON string = "IN_SEASON"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryLIMITEDREPLENISHMENT captures enum value "LIMITED_REPLENISHMENT"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryLIMITEDREPLENISHMENT string = "LIMITED_REPLENISHMENT"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryMANUFACTUREROUTOFSTOCK captures enum value "MANUFACTURER_OUT_OF_STOCK"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryMANUFACTUREROUTOFSTOCK string = "MANUFACTURER_OUT_OF_STOCK"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryNEWPRODUCT captures enum value "NEW_PRODUCT"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryNEWPRODUCT string = "NEW_PRODUCT"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryNONREPLENISHABLE captures enum value "NON_REPLENISHABLE"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryNONREPLENISHABLE string = "NON_REPLENISHABLE"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryNONSTOCKUPABLE captures enum value "NON_STOCKUPABLE"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryNONSTOCKUPABLE string = "NON_STOCKUPABLE"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryOBSOLETE captures enum value "OBSOLETE"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryOBSOLETE string = "OBSOLETE"

	// ItemVendorDetailsByMarketplaceReplenishmentCategoryPLANNEDREPLENISHMENT captures enum value "PLANNED_REPLENISHMENT"
	ItemVendorDetailsByMarketplaceReplenishmentCategoryPLANNEDREPLENISHMENT string = "PLANNED_REPLENISHMENT"
)

// prop value enum
func (m *ItemVendorDetailsByMarketplace) validateReplenishmentCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, itemVendorDetailsByMarketplaceTypeReplenishmentCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ItemVendorDetailsByMarketplace) validateReplenishmentCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplenishmentCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateReplenishmentCategoryEnum("replenishmentCategory", "body", m.ReplenishmentCategory); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this item vendor details by marketplace based on the context it is used
func (m *ItemVendorDetailsByMarketplace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProductCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProductSubcategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ItemVendorDetailsByMarketplace) contextValidateProductCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.ProductCategory != nil {
		if err := m.ProductCategory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productCategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productCategory")
			}
			return err
		}
	}

	return nil
}

func (m *ItemVendorDetailsByMarketplace) contextValidateProductSubcategory(ctx context.Context, formats strfmt.Registry) error {

	if m.ProductSubcategory != nil {
		if err := m.ProductSubcategory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productSubcategory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("productSubcategory")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ItemVendorDetailsByMarketplace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ItemVendorDetailsByMarketplace) UnmarshalBinary(b []byte) error {
	var res ItemVendorDetailsByMarketplace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
