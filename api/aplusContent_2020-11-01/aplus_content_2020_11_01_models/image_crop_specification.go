// Code generated by go-swagger; DO NOT EDIT.

package aplus_content_2020_11_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ImageCropSpecification The instructions for optionally cropping an image. If no cropping is desired, set the dimensions to the original image size. If the image is cropped and no offset values are provided, then the coordinates of the top left corner of the cropped image, relative to the original image, are defaulted to (0,0).
//
// swagger:model ImageCropSpecification
type ImageCropSpecification struct {

	// offset
	Offset *ImageOffsets `json:"offset,omitempty"`

	// size
	// Required: true
	Size *ImageDimensions `json:"size"`
}

// Validate validates this image crop specification
func (m *ImageCropSpecification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOffset(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ImageCropSpecification) validateOffset(formats strfmt.Registry) error {
	if swag.IsZero(m.Offset) { // not required
		return nil
	}

	if m.Offset != nil {
		if err := m.Offset.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offset")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offset")
			}
			return err
		}
	}

	return nil
}

func (m *ImageCropSpecification) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	if m.Size != nil {
		if err := m.Size.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this image crop specification based on the context it is used
func (m *ImageCropSpecification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOffset(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ImageCropSpecification) contextValidateOffset(ctx context.Context, formats strfmt.Registry) error {

	if m.Offset != nil {
		if err := m.Offset.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offset")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offset")
			}
			return err
		}
	}

	return nil
}

func (m *ImageCropSpecification) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if m.Size != nil {
		if err := m.Size.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ImageCropSpecification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ImageCropSpecification) UnmarshalBinary(b []byte) error {
	var res ImageCropSpecification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
