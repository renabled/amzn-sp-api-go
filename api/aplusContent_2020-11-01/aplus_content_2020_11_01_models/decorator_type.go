// Code generated by go-swagger; DO NOT EDIT.

package aplus_content_2020_11_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// DecoratorType The type of rich text decorator.
//
// swagger:model DecoratorType
type DecoratorType string

func NewDecoratorType(value DecoratorType) *DecoratorType {
	return &value
}

// Pointer returns a pointer to a freshly-allocated DecoratorType.
func (m DecoratorType) Pointer() *DecoratorType {
	return &m
}

const (

	// DecoratorTypeLISTITEM captures enum value "LIST_ITEM"
	DecoratorTypeLISTITEM DecoratorType = "LIST_ITEM"

	// DecoratorTypeLISTORDERED captures enum value "LIST_ORDERED"
	DecoratorTypeLISTORDERED DecoratorType = "LIST_ORDERED"

	// DecoratorTypeLISTUNORDERED captures enum value "LIST_UNORDERED"
	DecoratorTypeLISTUNORDERED DecoratorType = "LIST_UNORDERED"

	// DecoratorTypeSTYLEBOLD captures enum value "STYLE_BOLD"
	DecoratorTypeSTYLEBOLD DecoratorType = "STYLE_BOLD"

	// DecoratorTypeSTYLEITALIC captures enum value "STYLE_ITALIC"
	DecoratorTypeSTYLEITALIC DecoratorType = "STYLE_ITALIC"

	// DecoratorTypeSTYLELINEBREAK captures enum value "STYLE_LINEBREAK"
	DecoratorTypeSTYLELINEBREAK DecoratorType = "STYLE_LINEBREAK"

	// DecoratorTypeSTYLEPARAGRAPH captures enum value "STYLE_PARAGRAPH"
	DecoratorTypeSTYLEPARAGRAPH DecoratorType = "STYLE_PARAGRAPH"

	// DecoratorTypeSTYLEUNDERLINE captures enum value "STYLE_UNDERLINE"
	DecoratorTypeSTYLEUNDERLINE DecoratorType = "STYLE_UNDERLINE"
)

// for schema
var decoratorTypeEnum []interface{}

func init() {
	var res []DecoratorType
	if err := json.Unmarshal([]byte(`["LIST_ITEM","LIST_ORDERED","LIST_UNORDERED","STYLE_BOLD","STYLE_ITALIC","STYLE_LINEBREAK","STYLE_PARAGRAPH","STYLE_UNDERLINE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		decoratorTypeEnum = append(decoratorTypeEnum, v)
	}
}

func (m DecoratorType) validateDecoratorTypeEnum(path, location string, value DecoratorType) error {
	if err := validate.EnumCase(path, location, value, decoratorTypeEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this decorator type
func (m DecoratorType) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateDecoratorTypeEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this decorator type based on context it is used
func (m DecoratorType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
