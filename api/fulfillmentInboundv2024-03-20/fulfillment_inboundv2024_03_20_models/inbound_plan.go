// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_inboundv2024_03_20_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InboundPlan Inbound plan containing details of the inbound workflow.
// Example: {"contactInformation":{"email":"email@email.com","phoneNumber":"1234567890"},"createdAt":"2024-03-20T12:01:00Z","inboundPlanId":"wf1234abcd-1234-abcd-5678-1234abcd5678","lastUpdatedAt":"2024-03-28T13:15:30Z","marketplaceIds":["A2EUQ1WTGCTBG2"],"name":"FBA (03/20/2024, 12:01 PM)","packingOptions":[],"placementOptions":[],"shipments":[],"sourceAddress":{"addressLine1":"123 example street","addressLine2":"Floor 19","city":"Toronto","companyName":"Acme","countryCode":"CA","name":"name","postalCode":"M1M1M1","stateOrProvinceCode":"ON"},"status":"ACTIVE"}
//
// swagger:model InboundPlan
type InboundPlan struct {

	// contact information
	// Required: true
	ContactInformation *ContactInformation `json:"contactInformation"`

	// The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	// Required: true
	// Format: date-time
	CreatedAt *strfmt.DateTime `json:"createdAt"`

	// Identifier to an inbound plan.
	// Required: true
	// Max Length: 38
	// Min Length: 38
	// Pattern: ^[a-zA-Z0-9-]*$
	InboundPlanID *string `json:"inboundPlanId"`

	// The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	// Required: true
	// Format: date-time
	LastUpdatedAt *strfmt.DateTime `json:"lastUpdatedAt"`

	// Marketplace IDs.
	// Required: true
	MarketplaceIds []string `json:"marketplaceIds"`

	// The human-readable name of the inbound plan.
	// Required: true
	Name *string `json:"name"`

	// Packing options for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, only packing options for that placement option will be returned. If there are confirmed shipments, only packing options for those shipments will be returned. Query the packing option for more details.
	PackingOptions []*PackingOptionSummary `json:"packingOptions"`

	// Placement options for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, that will be the only returned option. Query the placement option for more details.
	PlacementOptions []*PlacementOptionSummary `json:"placementOptions"`

	// Shipment IDs for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, only shipments for that option will be returned. If there are confirmed shipments, only those shipments will be returned. Query the shipment for more details.
	Shipments []*ShipmentSummary `json:"shipments"`

	// source address
	// Required: true
	SourceAddress *Address `json:"sourceAddress"`

	// Current status of the inbound plan. Can be `ACTIVE`, `VOIDED`, or `SHIPPED`.
	// Required: true
	// Max Length: 1024
	// Min Length: 1
	Status *string `json:"status"`
}

// Validate validates this inbound plan
func (m *InboundPlan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContactInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInboundPlanID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketplaceIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackingOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacementOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InboundPlan) validateContactInformation(formats strfmt.Registry) error {

	if err := validate.Required("contactInformation", "body", m.ContactInformation); err != nil {
		return err
	}

	if m.ContactInformation != nil {
		if err := m.ContactInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contactInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contactInformation")
			}
			return err
		}
	}

	return nil
}

func (m *InboundPlan) validateCreatedAt(formats strfmt.Registry) error {

	if err := validate.Required("createdAt", "body", m.CreatedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InboundPlan) validateInboundPlanID(formats strfmt.Registry) error {

	if err := validate.Required("inboundPlanId", "body", m.InboundPlanID); err != nil {
		return err
	}

	if err := validate.MinLength("inboundPlanId", "body", *m.InboundPlanID, 38); err != nil {
		return err
	}

	if err := validate.MaxLength("inboundPlanId", "body", *m.InboundPlanID, 38); err != nil {
		return err
	}

	if err := validate.Pattern("inboundPlanId", "body", *m.InboundPlanID, `^[a-zA-Z0-9-]*$`); err != nil {
		return err
	}

	return nil
}

func (m *InboundPlan) validateLastUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("lastUpdatedAt", "body", m.LastUpdatedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("lastUpdatedAt", "body", "date-time", m.LastUpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InboundPlan) validateMarketplaceIds(formats strfmt.Registry) error {

	if err := validate.Required("marketplaceIds", "body", m.MarketplaceIds); err != nil {
		return err
	}

	for i := 0; i < len(m.MarketplaceIds); i++ {

		if err := validate.MinLength("marketplaceIds"+"."+strconv.Itoa(i), "body", m.MarketplaceIds[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("marketplaceIds"+"."+strconv.Itoa(i), "body", m.MarketplaceIds[i], 256); err != nil {
			return err
		}

	}

	return nil
}

func (m *InboundPlan) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *InboundPlan) validatePackingOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.PackingOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.PackingOptions); i++ {
		if swag.IsZero(m.PackingOptions[i]) { // not required
			continue
		}

		if m.PackingOptions[i] != nil {
			if err := m.PackingOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("packingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("packingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) validatePlacementOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.PlacementOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.PlacementOptions); i++ {
		if swag.IsZero(m.PlacementOptions[i]) { // not required
			continue
		}

		if m.PlacementOptions[i] != nil {
			if err := m.PlacementOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("placementOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("placementOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) validateShipments(formats strfmt.Registry) error {
	if swag.IsZero(m.Shipments) { // not required
		return nil
	}

	for i := 0; i < len(m.Shipments); i++ {
		if swag.IsZero(m.Shipments[i]) { // not required
			continue
		}

		if m.Shipments[i] != nil {
			if err := m.Shipments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shipments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) validateSourceAddress(formats strfmt.Registry) error {

	if err := validate.Required("sourceAddress", "body", m.SourceAddress); err != nil {
		return err
	}

	if m.SourceAddress != nil {
		if err := m.SourceAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceAddress")
			}
			return err
		}
	}

	return nil
}

func (m *InboundPlan) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.MinLength("status", "body", *m.Status, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("status", "body", *m.Status, 1024); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this inbound plan based on the context it is used
func (m *InboundPlan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContactInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePackingOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlacementOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InboundPlan) contextValidateContactInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.ContactInformation != nil {
		if err := m.ContactInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contactInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contactInformation")
			}
			return err
		}
	}

	return nil
}

func (m *InboundPlan) contextValidatePackingOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PackingOptions); i++ {

		if m.PackingOptions[i] != nil {
			if err := m.PackingOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("packingOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("packingOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) contextValidatePlacementOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PlacementOptions); i++ {

		if m.PlacementOptions[i] != nil {
			if err := m.PlacementOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("placementOptions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("placementOptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) contextValidateShipments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Shipments); i++ {

		if m.Shipments[i] != nil {
			if err := m.Shipments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shipments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InboundPlan) contextValidateSourceAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceAddress != nil {
		if err := m.SourceAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InboundPlan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InboundPlan) UnmarshalBinary(b []byte) error {
	var res InboundPlan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
