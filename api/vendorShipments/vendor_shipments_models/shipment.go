// Code generated by go-swagger; DO NOT EDIT.

package vendor_shipments_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Shipment shipment
//
// swagger:model Shipment
type Shipment struct {

	// The buyer Reference Number is a unique identifier generated by buyer for all Collect/WePay shipments when you submit a transportation request. This field is mandatory for Collect/WePay shipments.
	BuyerReferenceNumber string `json:"buyerReferenceNumber,omitempty"`

	// Indicates the earliest pickup date for the transportation from vendor warehouse. This information is mandatory to be filled for requesting transportation from Buyer (WePay/Collect).
	CollectFreightPickupDetails *CollectFreightPickupDetails `json:"collectFreightPickupDetails,omitempty"`

	// A list of the items in this transportation and their associated inner container details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.
	Containers []*Containers `json:"containers"`

	// Indicates the current shipment status.
	// Enum: [Created TransportationRequested CarrierAssigned Shipped]
	CurrentShipmentStatus string `json:"currentShipmentStatus,omitempty"`

	// Date and time when the last status was updated.
	// Format: date-time
	CurrentshipmentStatusDate strfmt.DateTime `json:"currentshipmentStatusDate,omitempty"`

	// Provide these fields only if this shipment is a direct import.
	ImportDetails *ImportDetails `json:"importDetails,omitempty"`

	// The date and time of the package label created for the shipment by buyer.
	// Format: date-time
	PackageLabelCreateDate strfmt.DateTime `json:"packageLabelCreateDate,omitempty"`

	// Indicates the purchase orders involved for the transportation request. This group is an array create 1 for each PO and list their corresponding items. This information is used for deciding the route,truck allocation and storage efficiently. This is a mandatory information for Buyer performing transportation from vendor warehouse (WePay/Collect)
	PurchaseOrders []*PurchaseOrders `json:"purchaseOrders"`

	// Name/Address and tax details of the selling party.
	// Required: true
	SellingParty *PartyIdentification `json:"sellingParty"`

	// Name/Address and tax details of the ship from party.
	// Required: true
	ShipFromParty *PartyIdentification `json:"shipFromParty"`

	// Name/Address of the destination warehouse where the shipment is being shipped to.
	// Required: true
	ShipToParty *PartyIdentification `json:"shipToParty"`

	// The date and time of the departure of the shipment from the vendor's location. Vendors are requested to send ASNs within 30 minutes of departure from their warehouse/distribution center or at least 6 hours prior to the appointment time at the Buyer destination warehouse, whichever is sooner. Shipped date mentioned in the shipment confirmation should not be in the future.
	// Format: date-time
	ShipmentConfirmDate strfmt.DateTime `json:"shipmentConfirmDate,omitempty"`

	// The date and time of the shipment request created by vendor.
	// Format: date-time
	ShipmentCreateDate strfmt.DateTime `json:"shipmentCreateDate,omitempty"`

	// Indicates if this transportation request is WePay/Collect or TheyPay/Prepaid. This is a mandatory information.
	// Enum: [Collect Prepaid]
	ShipmentFreightTerm string `json:"shipmentFreightTerm,omitempty"`

	// Indicates the shipment measurement details on how many cartons and pallets and the total transportation weight and volume as part of this request. This is a mandatory detail which will help determining the transportation cost, truck allocations and route determination efficiently.
	ShipmentMeasurements *TransportShipmentMeasurements `json:"shipmentMeasurements,omitempty"`

	// Indicates the list of current shipment status details and when the last update was received from carrier this is available on shipment Details response.
	ShipmentStatusDetails []*ShipmentStatusDetails `json:"shipmentStatusDetails"`

	// Date on which the transportation request was submitted.
	// Required: true
	// Format: date-time
	TransactionDate *strfmt.DateTime `json:"transactionDate"`

	// Indicates the type of  transportation request such as (New,Cancel,Confirm and PackageLabelRequest). Each transactiontype has a unique set of operation and there are corresponding details to be populated for each operation.
	// Required: true
	// Enum: [New Cancel]
	TransactionType *string `json:"transactionType"`

	// Transportation details this a mandatory information which states delivery date, shipping date and carrier details.
	TransportationDetails *TransportationDetails `json:"transportationDetails,omitempty"`

	// Unique Transportation ID created by Vendor (Should not be used over the last 365 days).
	// Required: true
	VendorShipmentIdentifier *string `json:"vendorShipmentIdentifier"`
}

// Validate validates this shipment
func (m *Shipment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCollectFreightPickupDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentShipmentStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentshipmentStatusDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageLabelCreateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurchaseOrders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellingParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipFromParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipToParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipmentConfirmDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipmentCreateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipmentFreightTerm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipmentMeasurements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipmentStatusDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransportationDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVendorShipmentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Shipment) validateCollectFreightPickupDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.CollectFreightPickupDetails) { // not required
		return nil
	}

	if m.CollectFreightPickupDetails != nil {
		if err := m.CollectFreightPickupDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("collectFreightPickupDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("collectFreightPickupDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.Containers) { // not required
		return nil
	}

	for i := 0; i < len(m.Containers); i++ {
		if swag.IsZero(m.Containers[i]) { // not required
			continue
		}

		if m.Containers[i] != nil {
			if err := m.Containers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var shipmentTypeCurrentShipmentStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Created","TransportationRequested","CarrierAssigned","Shipped"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shipmentTypeCurrentShipmentStatusPropEnum = append(shipmentTypeCurrentShipmentStatusPropEnum, v)
	}
}

const (

	// ShipmentCurrentShipmentStatusCreated captures enum value "Created"
	ShipmentCurrentShipmentStatusCreated string = "Created"

	// ShipmentCurrentShipmentStatusTransportationRequested captures enum value "TransportationRequested"
	ShipmentCurrentShipmentStatusTransportationRequested string = "TransportationRequested"

	// ShipmentCurrentShipmentStatusCarrierAssigned captures enum value "CarrierAssigned"
	ShipmentCurrentShipmentStatusCarrierAssigned string = "CarrierAssigned"

	// ShipmentCurrentShipmentStatusShipped captures enum value "Shipped"
	ShipmentCurrentShipmentStatusShipped string = "Shipped"
)

// prop value enum
func (m *Shipment) validateCurrentShipmentStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shipmentTypeCurrentShipmentStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shipment) validateCurrentShipmentStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentShipmentStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateCurrentShipmentStatusEnum("currentShipmentStatus", "body", m.CurrentShipmentStatus); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validateCurrentshipmentStatusDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentshipmentStatusDate) { // not required
		return nil
	}

	if err := validate.FormatOf("currentshipmentStatusDate", "body", "date-time", m.CurrentshipmentStatusDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validateImportDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportDetails) { // not required
		return nil
	}

	if m.ImportDetails != nil {
		if err := m.ImportDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("importDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("importDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validatePackageLabelCreateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.PackageLabelCreateDate) { // not required
		return nil
	}

	if err := validate.FormatOf("packageLabelCreateDate", "body", "date-time", m.PackageLabelCreateDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validatePurchaseOrders(formats strfmt.Registry) error {
	if swag.IsZero(m.PurchaseOrders) { // not required
		return nil
	}

	for i := 0; i < len(m.PurchaseOrders); i++ {
		if swag.IsZero(m.PurchaseOrders[i]) { // not required
			continue
		}

		if m.PurchaseOrders[i] != nil {
			if err := m.PurchaseOrders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchaseOrders" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("purchaseOrders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shipment) validateSellingParty(formats strfmt.Registry) error {

	if err := validate.Required("sellingParty", "body", m.SellingParty); err != nil {
		return err
	}

	if m.SellingParty != nil {
		if err := m.SellingParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sellingParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sellingParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateShipFromParty(formats strfmt.Registry) error {

	if err := validate.Required("shipFromParty", "body", m.ShipFromParty); err != nil {
		return err
	}

	if m.ShipFromParty != nil {
		if err := m.ShipFromParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipFromParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipFromParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateShipToParty(formats strfmt.Registry) error {

	if err := validate.Required("shipToParty", "body", m.ShipToParty); err != nil {
		return err
	}

	if m.ShipToParty != nil {
		if err := m.ShipToParty.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateShipmentConfirmDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipmentConfirmDate) { // not required
		return nil
	}

	if err := validate.FormatOf("shipmentConfirmDate", "body", "date-time", m.ShipmentConfirmDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validateShipmentCreateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipmentCreateDate) { // not required
		return nil
	}

	if err := validate.FormatOf("shipmentCreateDate", "body", "date-time", m.ShipmentCreateDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var shipmentTypeShipmentFreightTermPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Collect","Prepaid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shipmentTypeShipmentFreightTermPropEnum = append(shipmentTypeShipmentFreightTermPropEnum, v)
	}
}

const (

	// ShipmentShipmentFreightTermCollect captures enum value "Collect"
	ShipmentShipmentFreightTermCollect string = "Collect"

	// ShipmentShipmentFreightTermPrepaid captures enum value "Prepaid"
	ShipmentShipmentFreightTermPrepaid string = "Prepaid"
)

// prop value enum
func (m *Shipment) validateShipmentFreightTermEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shipmentTypeShipmentFreightTermPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shipment) validateShipmentFreightTerm(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipmentFreightTerm) { // not required
		return nil
	}

	// value enum
	if err := m.validateShipmentFreightTermEnum("shipmentFreightTerm", "body", m.ShipmentFreightTerm); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validateShipmentMeasurements(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipmentMeasurements) { // not required
		return nil
	}

	if m.ShipmentMeasurements != nil {
		if err := m.ShipmentMeasurements.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipmentMeasurements")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipmentMeasurements")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateShipmentStatusDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ShipmentStatusDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.ShipmentStatusDetails); i++ {
		if swag.IsZero(m.ShipmentStatusDetails[i]) { // not required
			continue
		}

		if m.ShipmentStatusDetails[i] != nil {
			if err := m.ShipmentStatusDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipmentStatusDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shipmentStatusDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shipment) validateTransactionDate(formats strfmt.Registry) error {

	if err := validate.Required("transactionDate", "body", m.TransactionDate); err != nil {
		return err
	}

	if err := validate.FormatOf("transactionDate", "body", "date-time", m.TransactionDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var shipmentTypeTransactionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["New","Cancel"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shipmentTypeTransactionTypePropEnum = append(shipmentTypeTransactionTypePropEnum, v)
	}
}

const (

	// ShipmentTransactionTypeNew captures enum value "New"
	ShipmentTransactionTypeNew string = "New"

	// ShipmentTransactionTypeCancel captures enum value "Cancel"
	ShipmentTransactionTypeCancel string = "Cancel"
)

// prop value enum
func (m *Shipment) validateTransactionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shipmentTypeTransactionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shipment) validateTransactionType(formats strfmt.Registry) error {

	if err := validate.Required("transactionType", "body", m.TransactionType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTransactionTypeEnum("transactionType", "body", *m.TransactionType); err != nil {
		return err
	}

	return nil
}

func (m *Shipment) validateTransportationDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.TransportationDetails) { // not required
		return nil
	}

	if m.TransportationDetails != nil {
		if err := m.TransportationDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transportationDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transportationDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateVendorShipmentIdentifier(formats strfmt.Registry) error {

	if err := validate.Required("vendorShipmentIdentifier", "body", m.VendorShipmentIdentifier); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this shipment based on the context it is used
func (m *Shipment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCollectFreightPickupDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImportDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePurchaseOrders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSellingParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipFromParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipToParty(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipmentMeasurements(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShipmentStatusDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransportationDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Shipment) contextValidateCollectFreightPickupDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.CollectFreightPickupDetails != nil {
		if err := m.CollectFreightPickupDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("collectFreightPickupDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("collectFreightPickupDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidateContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Containers); i++ {

		if m.Containers[i] != nil {
			if err := m.Containers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shipment) contextValidateImportDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.ImportDetails != nil {
		if err := m.ImportDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("importDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("importDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidatePurchaseOrders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PurchaseOrders); i++ {

		if m.PurchaseOrders[i] != nil {
			if err := m.PurchaseOrders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchaseOrders" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("purchaseOrders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shipment) contextValidateSellingParty(ctx context.Context, formats strfmt.Registry) error {

	if m.SellingParty != nil {
		if err := m.SellingParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sellingParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sellingParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidateShipFromParty(ctx context.Context, formats strfmt.Registry) error {

	if m.ShipFromParty != nil {
		if err := m.ShipFromParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipFromParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipFromParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidateShipToParty(ctx context.Context, formats strfmt.Registry) error {

	if m.ShipToParty != nil {
		if err := m.ShipToParty.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipToParty")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipToParty")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidateShipmentMeasurements(ctx context.Context, formats strfmt.Registry) error {

	if m.ShipmentMeasurements != nil {
		if err := m.ShipmentMeasurements.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipmentMeasurements")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("shipmentMeasurements")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) contextValidateShipmentStatusDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ShipmentStatusDetails); i++ {

		if m.ShipmentStatusDetails[i] != nil {
			if err := m.ShipmentStatusDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipmentStatusDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("shipmentStatusDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shipment) contextValidateTransportationDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.TransportationDetails != nil {
		if err := m.TransportationDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transportationDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transportationDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Shipment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Shipment) UnmarshalBinary(b []byte) error {
	var res Shipment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
