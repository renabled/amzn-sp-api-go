// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_inbound_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InboundShipmentItem Item information for an inbound shipment. Submitted with a call to the createInboundShipment or updateInboundShipment operation.
//
// swagger:model InboundShipmentItem
type InboundShipmentItem struct {

	// Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSKU string `json:"FulfillmentNetworkSKU,omitempty"`

	// prep details list
	PrepDetailsList PrepDetailsList `json:"PrepDetailsList,omitempty"`

	// The item quantity in each case, for case-packed items. Note that QuantityInCase multiplied by the number of boxes in the inbound shipment equals QuantityShipped. Also note that all of the boxes of an inbound shipment must either be case packed or individually packed. For that reason, when you submit the createInboundShipment or the updateInboundShipment operation, the value of QuantityInCase must be provided for every item in the shipment or for none of the items in the shipment.
	QuantityInCase Quantity `json:"QuantityInCase,omitempty"`

	// The item quantity that has been received at an Amazon fulfillment center.
	QuantityReceived Quantity `json:"QuantityReceived,omitempty"`

	// The item quantity that you are shipping.
	// Required: true
	QuantityShipped *Quantity `json:"QuantityShipped"`

	// The date that a pre-order item will be available for sale.
	// Format: date
	ReleaseDate DateStringType `json:"ReleaseDate,omitempty"`

	// The seller SKU of the item.
	// Required: true
	SellerSKU *string `json:"SellerSKU"`

	// A shipment identifier originally returned by the createInboundShipmentPlan operation.
	ShipmentID string `json:"ShipmentId,omitempty"`
}

// Validate validates this inbound shipment item
func (m *InboundShipmentItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePrepDetailsList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantityInCase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantityReceived(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantityShipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerSKU(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InboundShipmentItem) validatePrepDetailsList(formats strfmt.Registry) error {
	if swag.IsZero(m.PrepDetailsList) { // not required
		return nil
	}

	if err := m.PrepDetailsList.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("PrepDetailsList")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("PrepDetailsList")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) validateQuantityInCase(formats strfmt.Registry) error {
	if swag.IsZero(m.QuantityInCase) { // not required
		return nil
	}

	if err := m.QuantityInCase.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("QuantityInCase")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("QuantityInCase")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) validateQuantityReceived(formats strfmt.Registry) error {
	if swag.IsZero(m.QuantityReceived) { // not required
		return nil
	}

	if err := m.QuantityReceived.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("QuantityReceived")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("QuantityReceived")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) validateQuantityShipped(formats strfmt.Registry) error {

	if err := validate.Required("QuantityShipped", "body", m.QuantityShipped); err != nil {
		return err
	}

	if err := validate.Required("QuantityShipped", "body", m.QuantityShipped); err != nil {
		return err
	}

	if m.QuantityShipped != nil {
		if err := m.QuantityShipped.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("QuantityShipped")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("QuantityShipped")
			}
			return err
		}
	}

	return nil
}

func (m *InboundShipmentItem) validateReleaseDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ReleaseDate) { // not required
		return nil
	}

	if err := m.ReleaseDate.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ReleaseDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("ReleaseDate")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) validateSellerSKU(formats strfmt.Registry) error {

	if err := validate.Required("SellerSKU", "body", m.SellerSKU); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this inbound shipment item based on the context it is used
func (m *InboundShipmentItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePrepDetailsList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuantityInCase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuantityReceived(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuantityShipped(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReleaseDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InboundShipmentItem) contextValidatePrepDetailsList(ctx context.Context, formats strfmt.Registry) error {

	if err := m.PrepDetailsList.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("PrepDetailsList")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("PrepDetailsList")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) contextValidateQuantityInCase(ctx context.Context, formats strfmt.Registry) error {

	if err := m.QuantityInCase.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("QuantityInCase")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("QuantityInCase")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) contextValidateQuantityReceived(ctx context.Context, formats strfmt.Registry) error {

	if err := m.QuantityReceived.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("QuantityReceived")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("QuantityReceived")
		}
		return err
	}

	return nil
}

func (m *InboundShipmentItem) contextValidateQuantityShipped(ctx context.Context, formats strfmt.Registry) error {

	if m.QuantityShipped != nil {
		if err := m.QuantityShipped.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("QuantityShipped")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("QuantityShipped")
			}
			return err
		}
	}

	return nil
}

func (m *InboundShipmentItem) contextValidateReleaseDate(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ReleaseDate.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ReleaseDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("ReleaseDate")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InboundShipmentItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InboundShipmentItem) UnmarshalBinary(b []byte) error {
	var res InboundShipmentItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
