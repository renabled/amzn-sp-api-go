// Code generated by go-swagger; DO NOT EDIT.

package merchant_fulfillment_v0_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// AdditionalSellerInput Additional information required to purchase shipping.
//
// swagger:model AdditionalSellerInput
type AdditionalSellerInput struct {

	// The data type of the additional information.
	DataType string `json:"DataType,omitempty"`

	// value as address
	ValueAsAddress *Address `json:"ValueAsAddress,omitempty"`

	// The value when the data type is boolean.
	ValueAsBoolean bool `json:"ValueAsBoolean,omitempty"`

	// value as currency
	ValueAsCurrency *CurrencyAmount `json:"ValueAsCurrency,omitempty"`

	// value as dimension
	ValueAsDimension *Length `json:"ValueAsDimension,omitempty"`

	// The value when the data type is integer.
	ValueAsInteger int64 `json:"ValueAsInteger,omitempty"`

	// The value when the data type is string.
	ValueAsString string `json:"ValueAsString,omitempty"`

	// The value when the data type is a date-time formatted string.
	// Format: date-time
	ValueAsTimestamp Timestamp `json:"ValueAsTimestamp,omitempty"`

	// value as weight
	ValueAsWeight *Weight `json:"ValueAsWeight,omitempty"`
}

// Validate validates this additional seller input
func (m *AdditionalSellerInput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateValueAsAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueAsCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueAsDimension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueAsTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueAsWeight(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AdditionalSellerInput) validateValueAsAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueAsAddress) { // not required
		return nil
	}

	if m.ValueAsAddress != nil {
		if err := m.ValueAsAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsAddress")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) validateValueAsCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueAsCurrency) { // not required
		return nil
	}

	if m.ValueAsCurrency != nil {
		if err := m.ValueAsCurrency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsCurrency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsCurrency")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) validateValueAsDimension(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueAsDimension) { // not required
		return nil
	}

	if m.ValueAsDimension != nil {
		if err := m.ValueAsDimension.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsDimension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsDimension")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) validateValueAsTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueAsTimestamp) { // not required
		return nil
	}

	if err := m.ValueAsTimestamp.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ValueAsTimestamp")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("ValueAsTimestamp")
		}
		return err
	}

	return nil
}

func (m *AdditionalSellerInput) validateValueAsWeight(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueAsWeight) { // not required
		return nil
	}

	if m.ValueAsWeight != nil {
		if err := m.ValueAsWeight.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsWeight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsWeight")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this additional seller input based on the context it is used
func (m *AdditionalSellerInput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateValueAsAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValueAsCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValueAsDimension(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValueAsTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValueAsWeight(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AdditionalSellerInput) contextValidateValueAsAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.ValueAsAddress != nil {
		if err := m.ValueAsAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsAddress")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) contextValidateValueAsCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.ValueAsCurrency != nil {
		if err := m.ValueAsCurrency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsCurrency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsCurrency")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) contextValidateValueAsDimension(ctx context.Context, formats strfmt.Registry) error {

	if m.ValueAsDimension != nil {
		if err := m.ValueAsDimension.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsDimension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsDimension")
			}
			return err
		}
	}

	return nil
}

func (m *AdditionalSellerInput) contextValidateValueAsTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ValueAsTimestamp.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ValueAsTimestamp")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("ValueAsTimestamp")
		}
		return err
	}

	return nil
}

func (m *AdditionalSellerInput) contextValidateValueAsWeight(ctx context.Context, formats strfmt.Registry) error {

	if m.ValueAsWeight != nil {
		if err := m.ValueAsWeight.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ValueAsWeight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ValueAsWeight")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AdditionalSellerInput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AdditionalSellerInput) UnmarshalBinary(b []byte) error {
	var res AdditionalSellerInput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
