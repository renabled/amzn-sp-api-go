// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_inbound_2024_03_20_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Box Contains information about a box that is used in the inbound plan. The box is a container that holds multiple items.
//
// swagger:model Box
type Box struct {

	// The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which is generated after transportation has been confirmed) and the index of the box.
	// Max Length: 1024
	// Min Length: 1
	BoxID string `json:"boxId,omitempty"`

	// content information source
	ContentInformationSource BoxContentInformationSource `json:"contentInformationSource,omitempty"`

	// destination region
	DestinationRegion *Region `json:"destinationRegion,omitempty"`

	// dimensions
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Items contained within the box.
	Items []*Item `json:"items"`

	// Primary key to uniquely identify a Package (Box or Pallet).
	// Required: true
	// Max Length: 38
	// Min Length: 38
	// Pattern: ^[a-zA-Z0-9-]*$
	PackageID *string `json:"packageId"`

	// The number of containers where all other properties like weight or dimensions are identical.
	// Maximum: 10000
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Template name of the box.
	// Max Length: 1024
	// Min Length: 1
	TemplateName string `json:"templateName,omitempty"`

	// weight
	Weight *Weight `json:"weight,omitempty"`
}

// Validate validates this box
func (m *Box) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBoxID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentInformationSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestinationRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeight(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Box) validateBoxID(formats strfmt.Registry) error {
	if swag.IsZero(m.BoxID) { // not required
		return nil
	}

	if err := validate.MinLength("boxId", "body", m.BoxID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("boxId", "body", m.BoxID, 1024); err != nil {
		return err
	}

	return nil
}

func (m *Box) validateContentInformationSource(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentInformationSource) { // not required
		return nil
	}

	if err := m.ContentInformationSource.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("contentInformationSource")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("contentInformationSource")
		}
		return err
	}

	return nil
}

func (m *Box) validateDestinationRegion(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationRegion) { // not required
		return nil
	}

	if m.DestinationRegion != nil {
		if err := m.DestinationRegion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationRegion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationRegion")
			}
			return err
		}
	}

	return nil
}

func (m *Box) validateDimensions(formats strfmt.Registry) error {
	if swag.IsZero(m.Dimensions) { // not required
		return nil
	}

	if m.Dimensions != nil {
		if err := m.Dimensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dimensions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dimensions")
			}
			return err
		}
	}

	return nil
}

func (m *Box) validateItems(formats strfmt.Registry) error {
	if swag.IsZero(m.Items) { // not required
		return nil
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Box) validatePackageID(formats strfmt.Registry) error {

	if err := validate.Required("packageId", "body", m.PackageID); err != nil {
		return err
	}

	if err := validate.MinLength("packageId", "body", *m.PackageID, 38); err != nil {
		return err
	}

	if err := validate.MaxLength("packageId", "body", *m.PackageID, 38); err != nil {
		return err
	}

	if err := validate.Pattern("packageId", "body", *m.PackageID, `^[a-zA-Z0-9-]*$`); err != nil {
		return err
	}

	return nil
}

func (m *Box) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(m.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", m.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", m.Quantity, 10000, false); err != nil {
		return err
	}

	return nil
}

func (m *Box) validateTemplateName(formats strfmt.Registry) error {
	if swag.IsZero(m.TemplateName) { // not required
		return nil
	}

	if err := validate.MinLength("templateName", "body", m.TemplateName, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("templateName", "body", m.TemplateName, 1024); err != nil {
		return err
	}

	return nil
}

func (m *Box) validateWeight(formats strfmt.Registry) error {
	if swag.IsZero(m.Weight) { // not required
		return nil
	}

	if m.Weight != nil {
		if err := m.Weight.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("weight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("weight")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this box based on the context it is used
func (m *Box) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContentInformationSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDestinationRegion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDimensions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWeight(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Box) contextValidateContentInformationSource(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ContentInformationSource.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("contentInformationSource")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("contentInformationSource")
		}
		return err
	}

	return nil
}

func (m *Box) contextValidateDestinationRegion(ctx context.Context, formats strfmt.Registry) error {

	if m.DestinationRegion != nil {
		if err := m.DestinationRegion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destinationRegion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destinationRegion")
			}
			return err
		}
	}

	return nil
}

func (m *Box) contextValidateDimensions(ctx context.Context, formats strfmt.Registry) error {

	if m.Dimensions != nil {
		if err := m.Dimensions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dimensions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dimensions")
			}
			return err
		}
	}

	return nil
}

func (m *Box) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Box) contextValidateWeight(ctx context.Context, formats strfmt.Registry) error {

	if m.Weight != nil {
		if err := m.Weight.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("weight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("weight")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Box) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Box) UnmarshalBinary(b []byte) error {
	var res Box
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
