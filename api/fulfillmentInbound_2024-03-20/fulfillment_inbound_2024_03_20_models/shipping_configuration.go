// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_inbound_2024_03_20_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ShippingConfiguration The shipping configurations supported for the packing option. Available modes are ground small parcel, freight less-than-truckload (LTL), freight full-truckload (FTL) palletized, freight FTL non-palletized, ocean less-than-container-load (LCL), ocean full-container load (FCL), air small parcel, and air small parcel express.
//
// swagger:model ShippingConfiguration
type ShippingConfiguration struct {

	// Mode of shipment transportation that this option will provide. Can be: `GROUND_SMALL_PARCEL`, `FREIGHT_LTL`, `FREIGHT_FTL_PALLET`, `FREIGHT_FTL_NONPALLET`, `OCEAN_LCL`, `OCEAN_FCL`, `AIR_SMALL_PARCEL`, `AIR_SMALL_PARCEL_EXPRESS`.
	// Max Length: 1024
	// Min Length: 1
	ShippingMode string `json:"shippingMode,omitempty"`

	// Shipping program for the option. Can be: `AMAZON_PARTNERED_CARRIER`, `USE_YOUR_OWN_CARRIER`.
	// Max Length: 1024
	// Min Length: 1
	ShippingSolution string `json:"shippingSolution,omitempty"`
}

// Validate validates this shipping configuration
func (m *ShippingConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateShippingMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingSolution(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShippingConfiguration) validateShippingMode(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingMode) { // not required
		return nil
	}

	if err := validate.MinLength("shippingMode", "body", m.ShippingMode, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("shippingMode", "body", m.ShippingMode, 1024); err != nil {
		return err
	}

	return nil
}

func (m *ShippingConfiguration) validateShippingSolution(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingSolution) { // not required
		return nil
	}

	if err := validate.MinLength("shippingSolution", "body", m.ShippingSolution, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("shippingSolution", "body", m.ShippingSolution, 1024); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this shipping configuration based on context it is used
func (m *ShippingConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShippingConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShippingConfiguration) UnmarshalBinary(b []byte) error {
	var res ShippingConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
