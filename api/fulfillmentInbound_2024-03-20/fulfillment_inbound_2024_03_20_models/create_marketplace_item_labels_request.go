// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_inbound_2024_03_20_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateMarketplaceItemLabelsRequest The `createMarketplaceItemLabels` request.
// Example: {"height":25,"labelType":"STANDARD_FORMAT","localeCode":"en_US","marketplaceId":"A2EUQ1WTGCTBG2","mskuQuantities":[{"msku":"msku","quantity":5}],"pageType":"A4_21","width":100}
//
// swagger:model CreateMarketplaceItemLabelsRequest
type CreateMarketplaceItemLabelsRequest struct {

	// The height of the item label.
	// Maximum: 100
	// Minimum: 25
	Height float64 `json:"height,omitempty"`

	// label type
	// Required: true
	LabelType *LabelPrintType `json:"labelType"`

	// The locale code constructed from ISO 639 language code and ISO 3166-1 alpha-2 standard of country codes separated by an underscore character.
	// Pattern: ^[a-z]{2}_[A-Z]{2}$
	LocaleCode string `json:"localeCode,omitempty"`

	// The Marketplace ID. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) for a list of possible values.
	// Required: true
	// Max Length: 256
	// Min Length: 1
	MarketplaceID *string `json:"marketplaceId"`

	// Represents the quantity of an msku to print item labels for.
	// Required: true
	// Max Items: 100
	// Min Items: 1
	MskuQuantities []*MskuQuantity `json:"mskuQuantities"`

	// page type
	PageType ItemLabelPageType `json:"pageType,omitempty"`

	// The width of the item label.
	// Maximum: 100
	// Minimum: 25
	Width float64 `json:"width,omitempty"`
}

// Validate validates this create marketplace item labels request
func (m *CreateMarketplaceItemLabelsRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHeight(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabelType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocaleCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketplaceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMskuQuantities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWidth(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateHeight(formats strfmt.Registry) error {
	if swag.IsZero(m.Height) { // not required
		return nil
	}

	if err := validate.Minimum("height", "body", m.Height, 25, false); err != nil {
		return err
	}

	if err := validate.Maximum("height", "body", m.Height, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateLabelType(formats strfmt.Registry) error {

	if err := validate.Required("labelType", "body", m.LabelType); err != nil {
		return err
	}

	if err := validate.Required("labelType", "body", m.LabelType); err != nil {
		return err
	}

	if m.LabelType != nil {
		if err := m.LabelType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("labelType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("labelType")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateLocaleCode(formats strfmt.Registry) error {
	if swag.IsZero(m.LocaleCode) { // not required
		return nil
	}

	if err := validate.Pattern("localeCode", "body", m.LocaleCode, `^[a-z]{2}_[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateMarketplaceID(formats strfmt.Registry) error {

	if err := validate.Required("marketplaceId", "body", m.MarketplaceID); err != nil {
		return err
	}

	if err := validate.MinLength("marketplaceId", "body", *m.MarketplaceID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("marketplaceId", "body", *m.MarketplaceID, 256); err != nil {
		return err
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateMskuQuantities(formats strfmt.Registry) error {

	if err := validate.Required("mskuQuantities", "body", m.MskuQuantities); err != nil {
		return err
	}

	iMskuQuantitiesSize := int64(len(m.MskuQuantities))

	if err := validate.MinItems("mskuQuantities", "body", iMskuQuantitiesSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("mskuQuantities", "body", iMskuQuantitiesSize, 100); err != nil {
		return err
	}

	for i := 0; i < len(m.MskuQuantities); i++ {
		if swag.IsZero(m.MskuQuantities[i]) { // not required
			continue
		}

		if m.MskuQuantities[i] != nil {
			if err := m.MskuQuantities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mskuQuantities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mskuQuantities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validatePageType(formats strfmt.Registry) error {
	if swag.IsZero(m.PageType) { // not required
		return nil
	}

	if err := m.PageType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("pageType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("pageType")
		}
		return err
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) validateWidth(formats strfmt.Registry) error {
	if swag.IsZero(m.Width) { // not required
		return nil
	}

	if err := validate.Minimum("width", "body", m.Width, 25, false); err != nil {
		return err
	}

	if err := validate.Maximum("width", "body", m.Width, 100, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create marketplace item labels request based on the context it is used
func (m *CreateMarketplaceItemLabelsRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLabelType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMskuQuantities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePageType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) contextValidateLabelType(ctx context.Context, formats strfmt.Registry) error {

	if m.LabelType != nil {
		if err := m.LabelType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("labelType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("labelType")
			}
			return err
		}
	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) contextValidateMskuQuantities(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MskuQuantities); i++ {

		if m.MskuQuantities[i] != nil {
			if err := m.MskuQuantities[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mskuQuantities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mskuQuantities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateMarketplaceItemLabelsRequest) contextValidatePageType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.PageType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("pageType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("pageType")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateMarketplaceItemLabelsRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateMarketplaceItemLabelsRequest) UnmarshalBinary(b []byte) error {
	var res CreateMarketplaceItemLabelsRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
