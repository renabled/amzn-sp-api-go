// Code generated by go-swagger; DO NOT EDIT.

package fulfillment_outbound_2020_07_01_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FulfillmentOrderItem Item information for a fulfillment order.
//
// swagger:model FulfillmentOrderItem
type FulfillmentOrderItem struct {

	// The item quantity that was cancelled by the seller.
	// Required: true
	CancelledQuantity *Quantity `json:"cancelledQuantity"`

	// Item-specific text that displays in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableComment string `json:"displayableComment,omitempty"`

	// The estimated arrival date and time of the item quantity. Note that this value can change over time. If the shipment that contains the item quantity has been cancelled, estimatedArrivalDate is not returned.
	// Format: date-time
	EstimatedArrivalDate Timestamp `json:"estimatedArrivalDate,omitempty"`

	// The estimated date and time that the item quantity is scheduled to ship from the fulfillment center. Note that this value can change over time. If the shipment that contains the item quantity has been cancelled, estimatedShipDate is not returned.
	// Format: date-time
	EstimatedShipDate Timestamp `json:"estimatedShipDate,omitempty"`

	// Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSku string `json:"fulfillmentNetworkSku,omitempty"`

	// A message to the gift recipient, if applicable.
	GiftMessage string `json:"giftMessage,omitempty"`

	// Indicates whether the item is sellable or unsellable.
	OrderItemDisposition string `json:"orderItemDisposition,omitempty"`

	// The monetary value assigned by the seller to this item.
	PerUnitDeclaredValue *Money `json:"perUnitDeclaredValue,omitempty"`

	// The amount to be collected from the recipient for this item in a COD (Cash On Delivery) order.
	PerUnitPrice *Money `json:"perUnitPrice,omitempty"`

	// The tax on the amount to be collected from the recipient for this item in a COD (Cash On Delivery) order.
	PerUnitTax *Money `json:"perUnitTax,omitempty"`

	// quantity
	// Required: true
	Quantity *Quantity `json:"quantity"`

	// A fulfillment order item identifier submitted with a call to the createFulfillmentOrder operation.
	// Required: true
	SellerFulfillmentOrderItemID *string `json:"sellerFulfillmentOrderItemId"`

	// The seller SKU of the item.
	// Required: true
	SellerSku *string `json:"sellerSku"`

	// The item quantity that is unfulfillable.
	// Required: true
	UnfulfillableQuantity *Quantity `json:"unfulfillableQuantity"`
}

// Validate validates this fulfillment order item
func (m *FulfillmentOrderItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCancelledQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEstimatedArrivalDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEstimatedShipDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerUnitDeclaredValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerUnitTax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerFulfillmentOrderItemID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerSku(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnfulfillableQuantity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FulfillmentOrderItem) validateCancelledQuantity(formats strfmt.Registry) error {

	if err := validate.Required("cancelledQuantity", "body", m.CancelledQuantity); err != nil {
		return err
	}

	if err := validate.Required("cancelledQuantity", "body", m.CancelledQuantity); err != nil {
		return err
	}

	if m.CancelledQuantity != nil {
		if err := m.CancelledQuantity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cancelledQuantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cancelledQuantity")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) validateEstimatedArrivalDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EstimatedArrivalDate) { // not required
		return nil
	}

	if err := m.EstimatedArrivalDate.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("estimatedArrivalDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("estimatedArrivalDate")
		}
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) validateEstimatedShipDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EstimatedShipDate) { // not required
		return nil
	}

	if err := m.EstimatedShipDate.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("estimatedShipDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("estimatedShipDate")
		}
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) validatePerUnitDeclaredValue(formats strfmt.Registry) error {
	if swag.IsZero(m.PerUnitDeclaredValue) { // not required
		return nil
	}

	if m.PerUnitDeclaredValue != nil {
		if err := m.PerUnitDeclaredValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitDeclaredValue")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitDeclaredValue")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) validatePerUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(m.PerUnitPrice) { // not required
		return nil
	}

	if m.PerUnitPrice != nil {
		if err := m.PerUnitPrice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitPrice")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) validatePerUnitTax(formats strfmt.Registry) error {
	if swag.IsZero(m.PerUnitTax) { // not required
		return nil
	}

	if m.PerUnitTax != nil {
		if err := m.PerUnitTax.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitTax")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitTax")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) validateQuantity(formats strfmt.Registry) error {

	if err := validate.Required("quantity", "body", m.Quantity); err != nil {
		return err
	}

	if err := validate.Required("quantity", "body", m.Quantity); err != nil {
		return err
	}

	if m.Quantity != nil {
		if err := m.Quantity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quantity")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) validateSellerFulfillmentOrderItemID(formats strfmt.Registry) error {

	if err := validate.Required("sellerFulfillmentOrderItemId", "body", m.SellerFulfillmentOrderItemID); err != nil {
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) validateSellerSku(formats strfmt.Registry) error {

	if err := validate.Required("sellerSku", "body", m.SellerSku); err != nil {
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) validateUnfulfillableQuantity(formats strfmt.Registry) error {

	if err := validate.Required("unfulfillableQuantity", "body", m.UnfulfillableQuantity); err != nil {
		return err
	}

	if err := validate.Required("unfulfillableQuantity", "body", m.UnfulfillableQuantity); err != nil {
		return err
	}

	if m.UnfulfillableQuantity != nil {
		if err := m.UnfulfillableQuantity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unfulfillableQuantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("unfulfillableQuantity")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fulfillment order item based on the context it is used
func (m *FulfillmentOrderItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCancelledQuantity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEstimatedArrivalDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEstimatedShipDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePerUnitDeclaredValue(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePerUnitPrice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePerUnitTax(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuantity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnfulfillableQuantity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FulfillmentOrderItem) contextValidateCancelledQuantity(ctx context.Context, formats strfmt.Registry) error {

	if m.CancelledQuantity != nil {
		if err := m.CancelledQuantity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cancelledQuantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cancelledQuantity")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidateEstimatedArrivalDate(ctx context.Context, formats strfmt.Registry) error {

	if err := m.EstimatedArrivalDate.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("estimatedArrivalDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("estimatedArrivalDate")
		}
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidateEstimatedShipDate(ctx context.Context, formats strfmt.Registry) error {

	if err := m.EstimatedShipDate.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("estimatedShipDate")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("estimatedShipDate")
		}
		return err
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidatePerUnitDeclaredValue(ctx context.Context, formats strfmt.Registry) error {

	if m.PerUnitDeclaredValue != nil {
		if err := m.PerUnitDeclaredValue.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitDeclaredValue")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitDeclaredValue")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidatePerUnitPrice(ctx context.Context, formats strfmt.Registry) error {

	if m.PerUnitPrice != nil {
		if err := m.PerUnitPrice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitPrice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitPrice")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidatePerUnitTax(ctx context.Context, formats strfmt.Registry) error {

	if m.PerUnitTax != nil {
		if err := m.PerUnitTax.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perUnitTax")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perUnitTax")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidateQuantity(ctx context.Context, formats strfmt.Registry) error {

	if m.Quantity != nil {
		if err := m.Quantity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quantity")
			}
			return err
		}
	}

	return nil
}

func (m *FulfillmentOrderItem) contextValidateUnfulfillableQuantity(ctx context.Context, formats strfmt.Registry) error {

	if m.UnfulfillableQuantity != nil {
		if err := m.UnfulfillableQuantity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unfulfillableQuantity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("unfulfillableQuantity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FulfillmentOrderItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FulfillmentOrderItem) UnmarshalBinary(b []byte) error {
	var res FulfillmentOrderItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
