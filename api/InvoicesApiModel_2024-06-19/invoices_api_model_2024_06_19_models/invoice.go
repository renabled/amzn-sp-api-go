// Code generated by go-swagger; DO NOT EDIT.

package invoices_api_model_2024_06_19_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Invoice Provides detailed information about an invoice.
//
// swagger:model Invoice
type Invoice struct {

	// The date and time the invoice is issued. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	// Format: date-time
	Date strfmt.DateTime `json:"date,omitempty"`

	// If the invoice is in an error state, this attribute displays the error code.
	ErrorCode string `json:"errorCode,omitempty"`

	// The invoice identifier that is used by an external party. This is typically the government agency that authorized the invoice.
	ExternalInvoiceID string `json:"externalInvoiceId,omitempty"`

	// The response message from the government authority when there is an error during invoice issuance.
	GovResponse string `json:"govResponse,omitempty"`

	// The invoice identifier.
	ID string `json:"id,omitempty"`

	// The classification of the invoice type. This varies across marketplaces. Use the `getInvoicesAttributes` operation to check `invoiceType` options.
	InvoiceType string `json:"invoiceType,omitempty"`

	// Use this identifier in conjunction with `externalInvoiceId` to identify invoices from the same seller.
	Series string `json:"series,omitempty"`

	// The invoice status classification. Use the `getInvoicesAttributes` operation to check invoice status options.
	Status string `json:"status,omitempty"`

	// List with identifiers for the transactions associated to the invoice.
	TransactionIds []*TransactionIdentifier `json:"transactionIds"`

	// Classification of the transaction that originated this invoice. Use the `getInvoicesAttributes` operation to check `transactionType` options.
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this invoice
func (m *Invoice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionIds(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Invoice) validateTransactionIds(formats strfmt.Registry) error {
	if swag.IsZero(m.TransactionIds) { // not required
		return nil
	}

	for i := 0; i < len(m.TransactionIds); i++ {
		if swag.IsZero(m.TransactionIds[i]) { // not required
			continue
		}

		if m.TransactionIds[i] != nil {
			if err := m.TransactionIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transactionIds" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("transactionIds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this invoice based on the context it is used
func (m *Invoice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTransactionIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Invoice) contextValidateTransactionIds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TransactionIds); i++ {

		if m.TransactionIds[i] != nil {
			if err := m.TransactionIds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transactionIds" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("transactionIds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Invoice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Invoice) UnmarshalBinary(b []byte) error {
	var res Invoice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
